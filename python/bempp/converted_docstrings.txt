
// File: index.xml

// File: classBempp_1_1AbstractBoundaryOperator.xml
%feature("docstring") Bempp::AbstractBoundaryOperator "

Abstract boundary operator.

An AbstractBoundaryOperator represents a linear mapping $L : X \\\\to
Y$ between two function spaces $X : S \\\\to K^p$ (_domain_) and $Y :
T \\\\to K^q$ (_range_) defined on $n$-dimensional surfaces $S$ and
$T$ embedded in an $(n+1)$-dimensional domain. $K$ denotes either the
set of real or complex numbers. The surfaces $S$ and $T$ may be equal.

The function assembleWeakForm() can be used to construct the weak form
of the operator.

BasisFunctionType_ Type of the values of the (components of the) basis
functions into which functions acted upon by the operator are
expanded.  ResultType_ Type used to represent elements of the weak
form of the operator.

Both template parameters can take the following values: float, double,
std::complex<float> and std::complex<double>. Both types must have the
same precision: for instance, mixing float with std::complex<double>
is not allowed. If BasisFunctionType_ is set to a complex type, then
ResultType_ must be set to the same type.

C++ includes: abstract_boundary_operator.hpp ";

/*  Construction and destruction  */

%feature("docstring")
Bempp::AbstractBoundaryOperator::AbstractBoundaryOperator "

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";

%feature("docstring")
Bempp::AbstractBoundaryOperator::~AbstractBoundaryOperator "

Destructor. ";

%feature("docstring")  Bempp::AbstractBoundaryOperator::id "

Return the identifier of this operator.

If the weak form of this operator is cacheable, return a shared
pointer to a valid instance of a subclass of
AbstractBoundaryOperatorId that is guaranteed to be different for all
*logically different* abstract boundary operators.

If the weak form of this operator is not cacheable, return a null
shared pointer. This is the default implementation. ";

/*  Spaces  */

%feature("docstring")  Bempp::AbstractBoundaryOperator::domain "

Domain.

Return a shared pointer to the function space being the domain of this
operator. ";

%feature("docstring")  Bempp::AbstractBoundaryOperator::range "

Range.

Return a shared pointer to the function space being the range of this
operator. ";

%feature("docstring")  Bempp::AbstractBoundaryOperator::dualToRange "

Dual to range.

Return a shared pointer to the function space dual to the range of
this operator. ";

/*  Other attributes  */

%feature("docstring")  Bempp::AbstractBoundaryOperator::label "

Return the label of the operator. ";

%feature("docstring")  Bempp::AbstractBoundaryOperator::symmetry "

Return the symmetry properties of the operator.

The returned value should be treated as a bitwise combination of the
flags defined in the Symmetry enumeration type. ";

%feature("docstring")  Bempp::AbstractBoundaryOperator::isLocal "

Return whether this operator is local.

Suppose that an operator $A$ acting on a function $f(x)$ produces
another function $g(x)$. We say that $A$ is local if the value of $g$
at any point $x$ depends only on the values of $f$ in an infinitesimal
neighbourhood of $x$.

Multiplicative and differential operators are local and discretization
of their weak forms with finite elements leads to sparse matrices.
Conversely, integral operators are in general non-local and
discretization of their weak forms leads to dense matrices. ";

/*  Assembly  */

%feature("docstring")
Bempp::AbstractBoundaryOperator::assembleWeakForm "

Assemble and return the operator's weak form.

This function constructs a discrete linear operator representing the
matrix $L_{jk}$ with entries of the form

\\\\[L_{jk} = \\\\int_S \\\\phi_j L \\\\psi_k,\\\\]

where $L$ is the linear operator represented by this object, $S$
denotes the surface on which the domain function space $X$ is defined
and which is represented by the grid returned by domain.grid(),
$\\\\phi_j$ is a _test function_ from the space $Y'$ dual to the range
of the operator, $Y$, and $\\\\psi_k$ is a _trial function_ from the
domain space $X$. ";


// File: classBempp_1_1AbstractBoundaryOperatorComposition.xml
%feature("docstring") Bempp::AbstractBoundaryOperatorComposition "

Composition of two abstract boundary operators.

This class represents a composition (product) of two boundary
operators.

C++ includes: abstract_boundary_operator_composition.hpp ";

%feature("docstring")
Bempp::AbstractBoundaryOperatorComposition::AbstractBoundaryOperatorComposition
"

Constructor.

Construct an operator representing the product $M \\\\equiv L_1 L_2 :
X \\\\to Z$ of two boundary operators $L_1 : Y \\\\to Z$ and $L_2 : X
\\\\to Y$.

Parameters:
-----------

outer:  Operator $L_1$.

inner:  Operator $L_2$.

symmetry:  (Optional) Symmetry of the weak form of the composite
operator. Can be any combination of the flags defined in the
enumeration type Symmetry.

Both operators must be initialized and the range space of the operator
inner must be identical with the domain space of the operator outer,
otherwise an exception is thrown. Todo Add a parameter setting the
symmetry of the composite operator. ";

%feature("docstring")
Bempp::AbstractBoundaryOperatorComposition::isLocal "

Return whether this operator is local.

Suppose that an operator $A$ acting on a function $f(x)$ produces
another function $g(x)$. We say that $A$ is local if the value of $g$
at any point $x$ depends only on the values of $f$ in an infinitesimal
neighbourhood of $x$.

Multiplicative and differential operators are local and discretization
of their weak forms with finite elements leads to sparse matrices.
Conversely, integral operators are in general non-local and
discretization of their weak forms leads to dense matrices. ";


// File: classBempp_1_1AbstractBoundaryOperatorId.xml
%feature("docstring") Bempp::AbstractBoundaryOperatorId "

Base class for identifiers of an abstract boundary operator.

See AbstractBoundaryOperator::id() and Context::getWeakForm() for more
information about the use of boundary-operator identifiers for caching
weak forms.

C++ includes: abstract_boundary_operator_id.hpp ";

%feature("docstring")
Bempp::AbstractBoundaryOperatorId::~AbstractBoundaryOperatorId "";

%feature("docstring")  Bempp::AbstractBoundaryOperatorId::hash "";

%feature("docstring")  Bempp::AbstractBoundaryOperatorId::dump "";

%feature("docstring")  Bempp::AbstractBoundaryOperatorId::isEqual "";


// File: classBempp_1_1AbstractBoundaryOperatorPseudoinverse.xml
%feature("docstring") Bempp::AbstractBoundaryOperatorPseudoinverse "

Inverse or pseudoinverse of an abstract boundary operator.

C++ includes: abstract_boundary_operator_pseudoinverse.hpp ";

%feature("docstring")
Bempp::AbstractBoundaryOperatorPseudoinverse::AbstractBoundaryOperatorPseudoinverse
"";

%feature("docstring")
Bempp::AbstractBoundaryOperatorPseudoinverse::isLocal "

Return whether this operator is local.

Suppose that an operator $A$ acting on a function $f(x)$ produces
another function $g(x)$. We say that $A$ is local if the value of $g$
at any point $x$ depends only on the values of $f$ in an infinitesimal
neighbourhood of $x$.

Multiplicative and differential operators are local and discretization
of their weak forms with finite elements leads to sparse matrices.
Conversely, integral operators are in general non-local and
discretization of their weak forms leads to dense matrices. ";

%feature("docstring")
Bempp::AbstractBoundaryOperatorPseudoinverse::id "

Return the identifier of this operator.

If the weak form of this operator is cacheable, return a shared
pointer to a valid instance of a subclass of
AbstractBoundaryOperatorId that is guaranteed to be different for all
*logically different* abstract boundary operators.

If the weak form of this operator is not cacheable, return a null
shared pointer. This is the default implementation. ";


// File: classBempp_1_1AbstractBoundaryOperatorPseudoinverseId.xml
%feature("docstring") Bempp::AbstractBoundaryOperatorPseudoinverseId "";

%feature("docstring")
Bempp::AbstractBoundaryOperatorPseudoinverseId::AbstractBoundaryOperatorPseudoinverseId
"";

%feature("docstring")
Bempp::AbstractBoundaryOperatorPseudoinverseId::hash "";

%feature("docstring")
Bempp::AbstractBoundaryOperatorPseudoinverseId::dump "";

%feature("docstring")
Bempp::AbstractBoundaryOperatorPseudoinverseId::isEqual "";


// File: classBempp_1_1AbstractBoundaryOperatorSum.xml
%feature("docstring") Bempp::AbstractBoundaryOperatorSum "

Sum of two abstract boundary operators.

This class represents a sum of two boundary operators.

C++ includes: abstract_boundary_operator_sum.hpp ";

%feature("docstring")
Bempp::AbstractBoundaryOperatorSum::AbstractBoundaryOperatorSum "

Constructor.

Construct an operator representing the sum $M \\\\equiv L_1 + L_2$ of
two boundary operators $L_1 : X \\\\to Y$ and $L_2 : X \\\\to Y$.

Parameters:
-----------

term1:  Operator $L_1$.

term2:  Operator $L_2$.

symmetry:  (Optional) Symmetry of the weak form of the composite
operator. By default is taken as the logical product of the symmetries
of the two operands. Can be set to any combination of the flags
defined in the enumeration type Symmetry.

Both terms must be initialized and their domains, ranges and spaces
dual to ranges must be identical, otherwise an exception is thrown. ";

%feature("docstring")  Bempp::AbstractBoundaryOperatorSum::isLocal "

Return whether this operator is local.

Suppose that an operator $A$ acting on a function $f(x)$ produces
another function $g(x)$. We say that $A$ is local if the value of $g$
at any point $x$ depends only on the values of $f$ in an infinitesimal
neighbourhood of $x$.

Multiplicative and differential operators are local and discretization
of their weak forms with finite elements leads to sparse matrices.
Conversely, integral operators are in general non-local and
discretization of their weak forms leads to dense matrices. ";


// File: classBempp_1_1AcaApproximateLuInverse.xml
%feature("docstring") Bempp::AcaApproximateLuInverse "

Approximate LU decomposition of a H-matrix.

C++ includes: aca_approximate_lu_inverse.hpp ";

%feature("docstring")
Bempp::AcaApproximateLuInverse::AcaApproximateLuInverse "

Construct an approximate LU decomposition of a H-matrix.

Parameters:
-----------

fwdOp:  Operator represented internally as a H-matrix.

delta:  Requested approximation accuracy (M. Bebendorf recommends
delta = 0.1). ";

%feature("docstring")
Bempp::AcaApproximateLuInverse::~AcaApproximateLuInverse "";

%feature("docstring")  Bempp::AcaApproximateLuInverse::rowCount "

Number of rows of the operator. ";

%feature("docstring")  Bempp::AcaApproximateLuInverse::columnCount "

Number of columns of the operator. ";

%feature("docstring")  Bempp::AcaApproximateLuInverse::addBlock "

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::AcaApproximateLuInverse::asDiscreteAcaBoundaryOperator "

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")  Bempp::AcaApproximateLuInverse::domain "";

%feature("docstring")  Bempp::AcaApproximateLuInverse::range "";

%feature("docstring")
Bempp::AcaApproximateLuInverse::AcaApproximateLuInverse "";


// File: classBempp_1_1AcaGlobalAssembler.xml
%feature("docstring") Bempp::AcaGlobalAssembler "

ACA-mode assembler.

C++ includes: aca_global_assembler.hpp ";


// File: structBempp_1_1AcaOptions.xml
%feature("docstring") Bempp::AcaOptions "

Adaptive cross approximation (ACA) parameters.

C++ includes: assembly_options.hpp ";

%feature("docstring")  Bempp::AcaOptions::AcaOptions "

Initialize ACA parameters to default values. ";


// File: structBempp_1_1AhmedDofWrapper.xml
%feature("docstring") Bempp::AhmedDofWrapper "

An Ahmed-compatible degree-of-freedom type.

C++ includes: ahmed_aux.hpp ";

%feature("docstring")  Bempp::AhmedDofWrapper::getcenter "";


// File: classBempp_1_1AhmedLeafClusterArray.xml
%feature("docstring") Bempp::AhmedLeafClusterArray "

Encapsulation of an array of pointers to AHMED's blcluster objects.

C++ includes: ahmed_leaf_cluster_array.hpp ";

%feature("docstring")
Bempp::AhmedLeafClusterArray::AhmedLeafClusterArray "";

%feature("docstring")  Bempp::AhmedLeafClusterArray::size "";

%feature("docstring")
Bempp::AhmedLeafClusterArray::sortAccordingToClusterSize "

Sort cluster list, putting biggest clusters first. ";


// File: classBempp_1_1AhmedMblockArrayDeleter.xml
%feature("docstring") Bempp::AhmedMblockArrayDeleter "";

%feature("docstring")
Bempp::AhmedMblockArrayDeleter::AhmedMblockArrayDeleter "";


// File: structBempp_1_1AhmedTypeTraits.xml
%feature("docstring") Bempp::AhmedTypeTraits "";


// File: structBempp_1_1AhmedTypeTraits_3_01std_1_1complex_3_01double_01_4_01_4.xml
%feature("docstring") Bempp::AhmedTypeTraits< std::complex< double > >
" ";


// File: structBempp_1_1AhmedTypeTraits_3_01std_1_1complex_3_01float_01_4_01_4.xml
%feature("docstring") Bempp::AhmedTypeTraits< std::complex< float > >
" ";


// File: classBempp_1_1AssemblyOptions.xml
%feature("docstring") Bempp::AssemblyOptions "

Options determining how weak-form assembly is done.

C++ includes: assembly_options.hpp ";

/*  Assembly mode  */

%feature("docstring")  Bempp::AssemblyOptions::switchToDenseMode "

Use dense-matrix representations of weak forms of boundary integral
operators.

This is the default assembly mode. ";

%feature("docstring")  Bempp::AssemblyOptions::switchToAcaMode "

Use adaptive cross approximation (ACA) to obtain hierarchical-matrix
representations of weak forms of boundary integral operators.

Parameters:
-----------

acaOptions:  Parameters influencing the ACA algorithm. ";

%feature("docstring")  Bempp::AssemblyOptions::switchToDense "

Use dense-matrix representations of weak forms of boundary integral
operators.

Deprecated Use switchToDenseMode() instead. ";

%feature("docstring")  Bempp::AssemblyOptions::switchToAca "

Use adaptive cross approximation (ACA) to obtain hierarchical-matrix
representations of weak forms of boundary integral operators.

Deprecated Use switchToAcaMode() instead. ";

%feature("docstring")  Bempp::AssemblyOptions::assemblyMode "

Current assembly mode.

The assembly mode can be changed by calling switchToDenseMode() or
switchToAcaMode(). ";

%feature("docstring")  Bempp::AssemblyOptions::acaOptions "

Return the current adaptive cross approximation (ACA) settings.

These settings are only used in the ACA assembly mode, i.e. when
assemblyMode() returns ACA. ";

/*  Parallelization  */

%feature("docstring")  Bempp::AssemblyOptions::setMaxThreadCount "

Set the maximum number of threads used during the assembly.

maxThreadCount must be a positive number or AUTO. In the latter case
the number of threads is determined automatically. ";

%feature("docstring")  Bempp::AssemblyOptions::switchToTbb "

Set the maximum number of threads used during the assembly.

Deprecated Use setMaxThreadCount() instead. ";

%feature("docstring")  Bempp::AssemblyOptions::parallelizationOptions
"

Return current parallelization options. ";

/*  Miscellaneous  */

%feature("docstring")
Bempp::AssemblyOptions::enableSingularIntegralCaching "

Specify whether singular integrals are cached during weak-form
assembly.

If value == true, singular integrals are precalculated and stored in a
cache before filling the matrix of the discretized weak form of a
singular boundary operator. Otherwise these integrals are evaluated as
needed during the assembly of the weak form.

By default, singular integral caching is enabled. ";

%feature("docstring")
Bempp::AssemblyOptions::isSingularIntegralCachingEnabled "

Return whether singular integrals should be cached during weak-form
assembly.

See enableSingularIntegralCaching() for more information. ";

%feature("docstring")
Bempp::AssemblyOptions::enableSparseStorageOfMassMatrices "

Specify whether mass matrices should be stored in sparse format.

If value == true, assembled mass matrices are stored as sparse
matrices. Otherwise they are stored as dense matrices.

By default, sparse storage of mass matrices is enabled. ";

%feature("docstring")
Bempp::AssemblyOptions::isSparseStorageOfMassMatricesEnabled "

Return whether mass matrices should be stored in sparse format.

See enableSparseStorageOfMassMatrices() for more information. ";

%feature("docstring")  Bempp::AssemblyOptions::AssemblyOptions "";


// File: classBempp_1_1AutoTimer.xml
%feature("docstring") Bempp::AutoTimer "

Timer that on destruction outputs the time elapsed since construction.

C++ includes: auto_timer.hpp ";

%feature("docstring")  Bempp::AutoTimer::AutoTimer "

Constructor.

Parameters:
-----------

text:  Message to be printed on destruction. ";

%feature("docstring")  Bempp::AutoTimer::AutoTimer "";

%feature("docstring")  Bempp::AutoTimer::~AutoTimer "";


// File: classBempp_1_1BelosSolverWrapper.xml
%feature("docstring") Bempp::BelosSolverWrapper "";

%feature("docstring")  Bempp::BelosSolverWrapper::BelosSolverWrapper "";

%feature("docstring")  Bempp::BelosSolverWrapper::~BelosSolverWrapper
"";

%feature("docstring")  Bempp::BelosSolverWrapper::setPreconditioner "";

%feature("docstring")  Bempp::BelosSolverWrapper::initializeSolver "";

%feature("docstring")  Bempp::BelosSolverWrapper::solve "";


// File: classBempp_1_1BlockedBoundaryOperator.xml
%feature("docstring") Bempp::BlockedBoundaryOperator "

Boundary operator consisting of multiple blocks arranged in a matrix.

C++ includes: blocked_boundary_operator.hpp ";

%feature("docstring")
Bempp::BlockedBoundaryOperator::BlockedBoundaryOperator "

Constructor.

Parameters:
-----------

structure:  A BlockedOperatorStructure object determining the
operators occupying individual blocks.

All the boundary operators from a single column of structure must have
the same domain, and all the operators from a single row of structure
must have the same range and space dual to range. No row and no column
of structure must be completely empty (contain only uninitialized
BoundaryOperator objects). If these conditions are not satisfied, an
exception is thrown. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::block "

Return the operator from row row and column column.

If block ( row, column) is empty, an uninitialized BoundaryOperator
object is returned. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::isEmpty "

Return whether the block in row row and column column is empty. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::rowCount "

Return number of block rows. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::columnCount "

Return number of block columns. ";

%feature("docstring")
Bempp::BlockedBoundaryOperator::totalGlobalDofCountInDomains "

Return total number of global degrees of freedom in all domains. ";

%feature("docstring")
Bempp::BlockedBoundaryOperator::totalGlobalDofCountInRanges "

Return total number of global degrees of freedom in all ranges. ";

%feature("docstring")
Bempp::BlockedBoundaryOperator::totalGlobalDofCountInDualsToRanges "

Return total number of global degrees of freedom in all duals to
ranges. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::weakForm "

Return the weak form of this boundary operator.

The returned discrete operator represents the matrix \\\\[ L =
\\\\begin{bmatrix} L_{11} & L_{12} & \\\\dots & L_{1n} \\\\\\\\ L_{21}
& L_{22} & \\\\dots & L_{2n} \\\\\\\\ \\\\vdots & \\\\vdots &
\\\\ddots & \\\\vdots \\\\\\\\ L_{m1} & L_{m2} & \\\\dots & L_{mn}
\\\\end{bmatrix}, \\\\] where $L_{ij}$ is the weak form of the
operator from row *i* and column *j* of this blocked boundary
operator. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::domain "

Return the function space being the domain of all the operators from
column column of this blocked operator. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::range "

Return the function space being the range of all the operators from
row row of this blocked operator. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::dualToRange "

Return the function space dual to the range of all the operators from
row row of this blocked operator. ";

%feature("docstring")  Bempp::BlockedBoundaryOperator::apply "

Set y_inout := alpha * A * x_in + beta * y_inout, where A is this
operator. ";


// File: classBempp_1_1BlockedOperatorStructure.xml
%feature("docstring") Bempp::BlockedOperatorStructure "

Helper class used in construction of blocked boundary operators.

This class represents a matrix of boundary operators. To construct a
blocked boundary operator, store individual boundary operators in
appropriate rows and columns of a BlockedOperatorStructure object and
pass this object to the constructor of the BlockedBoundaryOperator
class for validation.

C++ includes: blocked_operator_structure.hpp ";

%feature("docstring")  Bempp::BlockedOperatorStructure::setBlock "

Store a boundary operator in a given block.

This function stores operator op in the block from row row and column
column, replacing any operator that might have been stored there
before.

Row and column numbers start from 0. ";

%feature("docstring")  Bempp::BlockedOperatorStructure::resetBlock "

Reset a block.

This function restores the original (uninitialized) state of the block
from row row and column column. ";

%feature("docstring")  Bempp::BlockedOperatorStructure::reset "

Reset all blocks.

This function restores the original (uninitialized) state of all
blocks. ";

%feature("docstring")  Bempp::BlockedOperatorStructure::block "

Return the boundary operator stored in a given block.

This function returns the boundary operator stored the block from row
row and column column, or a null (uninitialized) operator if no
operator has previously been assigned to this block. ";

%feature("docstring")  Bempp::BlockedOperatorStructure::isEmpty "

Return whether a block is empty.

This function returns true if no operator is stored in the block from
row row and column column, false otherwise. ";

%feature("docstring")  Bempp::BlockedOperatorStructure::rowCount "

Return the number of rows in the matrix.

This function returns the smallest number $m \\\\geq 0$ such that all
the blocks in rows with indices $m, m+1, \\\\dots$ are empty. ";

%feature("docstring")  Bempp::BlockedOperatorStructure::columnCount "

Return the number of columns in the matrix.

This function returns the smallest number $n \\\\geq 0$ such that all
the blocks in columns with indices $n, n+1, \\\\dots$ are empty. ";


// File: classBempp_1_1BlockedSolution.xml
%feature("docstring") Bempp::BlockedSolution "

This class holds the solution of a block operator system together with
various information about the solution.

C++ includes: blocked_solution.hpp ";

%feature("docstring")  Bempp::BlockedSolution::BlockedSolution "

Constructor. ";

%feature("docstring")  Bempp::BlockedSolution::BlockedSolution "

Constructor. ";

%feature("docstring")  Bempp::BlockedSolution::gridFunctionCount "";

%feature("docstring")  Bempp::BlockedSolution::gridFunction "";

%feature("docstring")  Bempp::BlockedSolution::gridFunction "";


// File: classBempp_1_1BoundaryOperator.xml
%feature("docstring") Bempp::BoundaryOperator "

Operator acting on functions defined on a surface.

A BoundaryOperator is a lightweight wrapper of a pair of shared
pointers to an AbstractBoundaryOperator and a DiscreteBoundaryOperator
representing the weak form of the former. The weak form is evaluated
lazily, on the first call to weakForm(). The Context object passed to
the constructor of the BoundaryOperator or to the initialize()
function determines how this weak form is calculated.

Different threads should not share BoundaryOperator objects, since
notably the weakForm() function is not thread-safe. Instead, each
thread should hold its own copy of a BoundaryOperator (note that
copying BoundaryOperators is cheap -- the copy constructor is
shallow).  See the documentation of AbstractBoundaryOperator for the
decription of the template parameters BasisFunctionType and
ResultType.

C++ includes: boundary_operator.hpp ";

%feature("docstring")  Bempp::BoundaryOperator::BoundaryOperator "

Construct an uninitialized BoundaryOperator. ";

%feature("docstring")  Bempp::BoundaryOperator::BoundaryOperator "

Construct and initialize a BoundaryOperator.

Equivalent to calling the initialize() function on a BoundaryOperator
object created with the default constructor. See the documentation of
initialize() for a description of the constructor's parameters.

User code should not need to invoke this constructor directly; it is
more convenient to use non-member constructors supplied with
particular AbstractBoundaryOperator subclasses (e.g.
laplace3dSingleLayerBoundaryOperator(), identityOperator(),
pseudoinverse() etc.), which construct an AbstractBoundaryOperator and
wrap it in a BoundaryOperator in a single step. ";

%feature("docstring")  Bempp::BoundaryOperator::initialize "

Initialize or reinitialize a BoundaryOperator.

Parameters:
-----------

context:  Shared pointer to a Context object that will be used to
build the weak form of abstractOp when necessary.

abstractOp:  Shared pointer to an AbstractBoundaryOperator that will
be encapsulated in this BoundaryOperator.

An exception is thrown if either of these pointers is NULL.

The provided shared pointers are stored in internal variables. In
addition, any stored pointer to the weak form of the abstract boundary
operator is invalidated. ";

%feature("docstring")  Bempp::BoundaryOperator::uninitialize "

Uninitialize the BoundaryOperator.

This function resets the internal shared pointers to the abstract
boundary operator and its weak form to NULL. ";

%feature("docstring")  Bempp::BoundaryOperator::isInitialized "

Return true if the BoundaryOperator has been initialized, false
otherwise. ";

%feature("docstring")  Bempp::BoundaryOperator::abstractOperator "

Return a shared pointer to the encapsulated abstract boundary
operator. ";

%feature("docstring")  Bempp::BoundaryOperator::context "

Return a shared pointer to the stored Context object. ";

%feature("docstring")  Bempp::BoundaryOperator::weakForm "

Return a shared pointer to the weak form of the encapsulated abstract
boundary operator.

An exception is thrown if this function is called on an uninitialized
BoundaryOperator. ";

%feature("docstring")  Bempp::BoundaryOperator::domain "

Return a shared pointer to the domain of the encapsulated abstract
boundary operator.

A null pointer is returned if this function is called on an
uninitialized BoundaryOperator. ";

%feature("docstring")  Bempp::BoundaryOperator::range "

Return a shared pointer to the range of the encapsulated abstract
boundary operator.

A null pointer is returned if this function is called on an
uninitialized BoundaryOperator. ";

%feature("docstring")  Bempp::BoundaryOperator::dualToRange "

Return a shared pointer to the space dual to the range of the
encapsulated abstract boundary operator.

A null pointer is returned if this function is called on an
uninitialized BoundaryOperator. ";

%feature("docstring")  Bempp::BoundaryOperator::label "

Return the label of this BoundaryOperator. ";

%feature("docstring")  Bempp::BoundaryOperator::apply "

Act on a GridFunction.

This function sets y_inout to alpha * A * x_in + beta * y_inout, where
A is the operator represented by this object.

The space of x_in must be identical with the domain of the
encapsulated abstract boundary operator, whereas the space of y_inout
and its dual must be identical with the range of the encapsulated
abstract boundary operator and its dual; otherwise an exception is
thrown. An exception is also thrown if the BoundaryOperator is
uninitialized. ";


// File: structBempp_1_1ChunkStatistics.xml
%feature("docstring") Bempp::ChunkStatistics "

Storage of parallel-loop profiling data.

C++ includes: chunk_statistics.hpp ";

%feature("docstring")  Bempp::ChunkStatistics::ChunkStatistics "";


// File: structBempp_1_1CompareSharedPtrsToConstAbstractBoundaryOperatorIds.xml
%feature("docstring")
Bempp::CompareSharedPtrsToConstAbstractBoundaryOperatorIds "";


// File: classBempp_1_1ConcreteElementMapper.xml
%feature("docstring") Bempp::ConcreteElementMapper "

An injective mapping from the full set of codimension-0 entities
(\"elements\") of a grid to the integers 0 ... (number of entities -
1).

C++ includes: concrete_element_mapper.hpp ";

%feature("docstring")
Bempp::ConcreteElementMapper::ConcreteElementMapper "";

%feature("docstring")  Bempp::ConcreteElementMapper::size "

Total number of entities in the entity set managed by the mapper. ";

%feature("docstring")  Bempp::ConcreteElementMapper::entityIndex "

Index of the entity of codimension 0.

The result of calling this method with an entity that does not belong
to the mapped set is undefined.

An index in the range 0 ... ( size() - 1). ";

%feature("docstring")  Bempp::ConcreteElementMapper::entityIndex "

Index of the entity of codimension 1.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::ConcreteElementMapper::entityIndex "

Index of the entity of codimension 2.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::ConcreteElementMapper::entityIndex "

Index of the entity of codimension 3.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::ConcreteElementMapper::subEntityIndex "

Index of i'th subentity of codimension codimSub of entity e of
codimension 0. ";


// File: classBempp_1_1ConcreteEntity.xml
%feature("docstring") Bempp::ConcreteEntity "

Wrapper of a Dune entity of type DuneEntity and codimension codim.

The codimension must be given explicitly (even though it could be
derived from the traits of DuneEntity) because this class needs to be
specialised for entities of codimension 0.

C++ includes: concrete_entity_decl.hpp ";

%feature("docstring")  Bempp::ConcreteEntity::ConcreteEntity "

Default constructor. ";

%feature("docstring")  Bempp::ConcreteEntity::ConcreteEntity "

Constructor from a pointer to DuneEntity.

This object does not acquire ownership of *dune_entity. ";

%feature("docstring")  Bempp::ConcreteEntity::duneEntity "

Read-only access to the underlying Dune entity object. ";

%feature("docstring")  Bempp::ConcreteEntity::level "

Entity level. ";

%feature("docstring")  Bempp::ConcreteEntity::geometry "

Reference to the geometry of this entity.

This object gives, among other things, the map from a reference
element to world coordinates.

Be careful when storing such references. If the state of any object is
changed, e.g. an iterator is advanced, there is no guarantee that the
reference remains valid. ";

%feature("docstring")  Bempp::ConcreteEntity::type "

Type of the reference element.

The type can be used to access the Dune::GenericReferenceElement. ";


// File: classBempp_1_1ConcreteEntity_3_010_00_01DuneEntity_01_4.xml
%feature("docstring") Bempp::ConcreteEntity< 0, DuneEntity > "

Wrapper of a Dune entity of type DuneEntity and codimension 0.

C++ includes: concrete_entity_decl.hpp ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity
>::ConcreteEntity "

Default constructor. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity
>::ConcreteEntity "

Constructor from a pointer to DuneEntity.

This object does not acquire ownership of *dune_entity. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity
>::duneEntity "

Read-only access to the underlying Dune entity object. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity >::level "

Entity level ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity
>::geometry "

Reference to the geometry of this entity.

This object gives, among other things, the map from a reference
element to world coordinates.

Be careful when storing such references. If the state of any object is
changed, e.g. an iterator is advanced, there is no guarantee that the
reference remains valid. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity >::type "

Type of the reference element.

The type can be used to access the Dune::GenericReferenceElement. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity >::father
"

Inter-level access to father entity on the next-coarser grid.

The given entity resulted directly from a subdivision of its father
entity. For macro (level-0) elements a null unique_ptr is returned.

If the partitionType of the Entity is GhostEntity, it is not
guaranteed that this method is working or implemented in general. For
some grids it might be available, though. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity
>::hasFather "

True if entity has a father entity which can be accessed using the
father() method. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity >::isLeaf
"

True if the entity is contained in the leaf grid. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity
>::isRegular "

True if the element is of regular type in red/green type refinement.

In bisection or hanging node refinement this is always true. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity
>::sonIterator "

Inter-level access to elements that resulted from (recursive)
subdivision of this element.

Parameters:
-----------

maxlevel:  Iterator does not stop at elements with level greater than
maxlevel.

Iterator to the first son (level is not greater than maxlevel)

If the partitionType of the Entity is GhostEntity, it is not
guaranteed that this method is working or implemented in general. For
some grids it might be available, though. ";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity >::isNew "

True if the entity has been created during the last call to adapt().
";

%feature("docstring")  Bempp::ConcreteEntity< 0, DuneEntity
>::mightVanish "

True if the entity might disappear during the next call to adapt().

If the method returns false, the entity is guaranteed to still be
present after adaptation. ";


// File: classBempp_1_1ConcreteEntityPointer.xml
%feature("docstring") Bempp::ConcreteEntityPointer "

Wrapper of a Dune entity pointer of type DuneEntityPointer.

C++ includes: concrete_entity_pointer.hpp ";

%feature("docstring")
Bempp::ConcreteEntityPointer::ConcreteEntityPointer "

Constructor. ";

%feature("docstring")  Bempp::ConcreteEntityPointer::entity "

Read-only access to the underlying entity. ";


// File: classBempp_1_1ConcreteGeometry.xml
%feature("docstring") Bempp::ConcreteGeometry "";

%feature("docstring")  Bempp::ConcreteGeometry::ConcreteGeometry "

Constructor from a pointer to DuneGeometry.

This object does not assume ownership of *dune_geometry. ";

%feature("docstring")  Bempp::ConcreteGeometry::~ConcreteGeometry "";

%feature("docstring")  Bempp::ConcreteGeometry::duneGeometry "

Read-only access to the underlying Dune geometry object. ";

%feature("docstring")  Bempp::ConcreteGeometry::dim "";

%feature("docstring")  Bempp::ConcreteGeometry::dimWorld "";

%feature("docstring")  Bempp::ConcreteGeometry::setupImpl "";

%feature("docstring")  Bempp::ConcreteGeometry::type "";

%feature("docstring")  Bempp::ConcreteGeometry::affine "";

%feature("docstring")  Bempp::ConcreteGeometry::cornerCount "";

%feature("docstring")  Bempp::ConcreteGeometry::getCornersImpl "

In future this copying should be optimised away by casting appropriate
columns of c to Dune field vectors. But this can't be done until unit
tests are in place. ";

%feature("docstring")  Bempp::ConcreteGeometry::local2globalImpl "

Optimise (get rid of data copying). ";

%feature("docstring")  Bempp::ConcreteGeometry::global2localImpl "

Optimise (get rid of data copying). ";

%feature("docstring")
Bempp::ConcreteGeometry::getIntegrationElementsImpl "

Optimise (get rid of data copying). ";

%feature("docstring")  Bempp::ConcreteGeometry::volume "";

%feature("docstring")  Bempp::ConcreteGeometry::getCenterImpl "

Optimise (get rid of data copying). ";

%feature("docstring")
Bempp::ConcreteGeometry::getJacobiansTransposedImpl "

Bug Unfortunately Dune::FieldMatrix (the underlying type of
JacobianTransposed) stores elements rowwise, while Armadillo does it
columnwise. Hence element-by-element filling of jacobian_t seems
unavoidable).

However, this bit of data copying could be avoided. ";

%feature("docstring")
Bempp::ConcreteGeometry::getJacobianInversesTransposedImpl "

Bug Unfortunately Dune::FieldMatrix (the underlying type of Jacobian)
stores elements rowwise, while Armadillo does it columnwise. Hence
element-by-element filling of jacobian_t seems unavoidable).

However, this bit of data copying could be avoided. ";

%feature("docstring")  Bempp::ConcreteGeometry::getNormalsImpl "";

%feature("docstring")  Bempp::ConcreteGeometry::getDataImpl "";


// File: classBempp_1_1ConcreteGeometryFactory.xml
%feature("docstring") Bempp::ConcreteGeometryFactory "

Factory able to construct an \"empty\" geometry wrapping a Dune
geometry of type DuneGeometry.

For internal use (in integrators from the Fiber module).

C++ includes: concrete_geometry_factory.hpp ";


// File: classBempp_1_1ConcreteGrid.xml
%feature("docstring") Bempp::ConcreteGrid "

Wrapper of a Dune surface grid of type DuneGrid.

C++ includes: concrete_grid.hpp ";

/*  Grid parameters  */

%feature("docstring")  Bempp::ConcreteGrid::dimWorld "

Dimension of the space containing the grid. ";

%feature("docstring")  Bempp::ConcreteGrid::dim "

Dimension of the grid. ";

%feature("docstring")  Bempp::ConcreteGrid::maxLevel "

Maximum level defined in this grid.

Levels are numbered 0 ... maxLevel() with 0 the coarsest level. ";

%feature("docstring")  Bempp::ConcreteGrid::boundarySegmentCount "

Number of boundary segments within the macro (level-0) grid. ";

/*  Views  */

%feature("docstring")  Bempp::ConcreteGrid::levelView "

View of the entities on grid level level. ";

%feature("docstring")  Bempp::ConcreteGrid::leafView "

View of the leaf entities. ";

/*  Geometry factory  */

%feature("docstring")  Bempp::ConcreteGrid::elementGeometryFactory "

Factory able to construct empty geometries of codimension 0 compatible
with this grid.

For internal use. Todo Provide implementations for other codimensions.
";

/*  Id sets  */

%feature("docstring")  Bempp::ConcreteGrid::globalIdSet "

Reference to the grid's global id set. ";

%feature("docstring")  Bempp::ConcreteGrid::topology "

Get the grid topology. ";

%feature("docstring")  Bempp::ConcreteGrid::ConcreteGrid "

Wrap a new Dune grid object (deleted in the destructor).

Wrap an existing Dune grid object.

Parameters:
-----------

dune_grid:  Pointer to the Dune grid to wrap.

topology:  The topology of the grid

own:  If true, *dune_grid is deleted in this object's destructor. ";

%feature("docstring")  Bempp::ConcreteGrid::~ConcreteGrid "

Destructor. ";

%feature("docstring")  Bempp::ConcreteGrid::duneGrid "

Read-only access to the underlying Dune grid object. ";

%feature("docstring")  Bempp::ConcreteGrid::duneGrid "

Access to the underlying Dune grid object. Use at your own risk! ";


// File: classBempp_1_1ConcreteGridView.xml
%feature("docstring") Bempp::ConcreteGridView "

Wrapper of a Dune grid view of type DuneGridView.

C++ includes: concrete_grid_view.hpp ";

%feature("docstring")  Bempp::ConcreteGridView::ConcreteGridView "

Constructor. ";

%feature("docstring")  Bempp::ConcreteGridView::duneGridView "

Read-only access to the underlying Dune grid view object. ";

%feature("docstring")  Bempp::ConcreteGridView::duneGridView "

Access to the underlying Dune grid view object. Use at your own risk!
";

%feature("docstring")  Bempp::ConcreteGridView::indexSet "

The index set. ";

%feature("docstring")  Bempp::ConcreteGridView::elementMapper "

The element mapper. ";

%feature("docstring")  Bempp::ConcreteGridView::entityCount "

Number of entities with codimension codim. ";

%feature("docstring")  Bempp::ConcreteGridView::entityCount "

Number of entities with geometry type type. ";

%feature("docstring")  Bempp::ConcreteGridView::containsEntity "

True if the entity e of codimension 0 is contained in this grid view.

If e is not an element of the grid, then the result of
containsEntity() is undefined. ";

%feature("docstring")  Bempp::ConcreteGridView::containsEntity "

True if the entity e of codimension 1 is contained in this grid view.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::ConcreteGridView::containsEntity "

True if the entity e of codimension 2 is contained in this grid view.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::ConcreteGridView::containsEntity "

True if the entity e of codimension 3 is contained in this grid view.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")
Bempp::ConcreteGridView::getRawElementDataDoubleImpl "";

%feature("docstring")
Bempp::ConcreteGridView::getRawElementDataFloatImpl "";

%feature("docstring")  Bempp::ConcreteGridView::reverseElementMapper "

Mapping from codim-0 entity index to entity pointer.

Note that this object is *not* updated when the grid is adapted. In
that case you need to create a new grid view and obtain a new
reference to the reverse element mapper. ";

%feature("docstring")  Bempp::ConcreteGridView::vtkWriter "

Create a VtkWriter for this grid view.

Parameters:
-----------

dm:  Data mode (conforming or nonconforming; see the documentation of
Dune::VTK::DataMode for details). ";


// File: classBempp_1_1ConcreteIdSet.xml
%feature("docstring") Bempp::ConcreteIdSet "

Wrapper of a Dune id set of type DuneIdSet providing access to the
entities of a Dune grid of type DuneGrid.

C++ includes: concrete_id_set.hpp ";

%feature("docstring")  Bempp::ConcreteIdSet::ConcreteIdSet "

Constructor.

This object does not assume ownership of *dune_id_set. ";

%feature("docstring")  Bempp::ConcreteIdSet::duneIdSet "

Read-only access to the underlying Dune id set. ";

%feature("docstring")  Bempp::ConcreteIdSet::entityId "

Id of the entity e of codimension 0. ";

%feature("docstring")  Bempp::ConcreteIdSet::entityId "

Id of the entity e of codimension 1. ";

%feature("docstring")  Bempp::ConcreteIdSet::entityId "

Id of the entity e of codimension 2. ";

%feature("docstring")  Bempp::ConcreteIdSet::entityId "

Id of the entity e of codimension 3. ";

%feature("docstring")  Bempp::ConcreteIdSet::subEntityId "

Id of i'th subentity of codimension codimSub of entity e of
codimension 0. ";


// File: classBempp_1_1ConcreteIndexSet.xml
%feature("docstring") Bempp::ConcreteIndexSet "

Wrapper of the index set specific to a Dune grid view class
DuneGridView.

C++ includes: concrete_index_set.hpp ";

%feature("docstring")  Bempp::ConcreteIndexSet::ConcreteIndexSet "

Constructor.

This object does not assume ownership of *dune_index_set. ";

%feature("docstring")  Bempp::ConcreteIndexSet::duneIndexSet "

Read-only access to the underlying Dune index set. ";

%feature("docstring")  Bempp::ConcreteIndexSet::entityIndex "

Index of the entity of codimension 0.

The result of calling this method with an entity that is not in the
index set is undefined.

An index in the range 0 ... (max number of entities in set - 1). ";

%feature("docstring")  Bempp::ConcreteIndexSet::entityIndex "

Index of the entity of codimension 1.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::ConcreteIndexSet::entityIndex "

Index of the entity of codimension 2.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::ConcreteIndexSet::entityIndex "

Index of the entity of codimension 3.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::ConcreteIndexSet::subEntityIndex "

Index of i'th subentity of codimension codimSub of entity e of
codimension 0. ";


// File: classBempp_1_1ConcreteRangeEntityIterator.xml
%feature("docstring") Bempp::ConcreteRangeEntityIterator "

Iterator over entities referenced by a range of Dune iterators of type
DuneEntityIt.

DuneEntityPointer is the base class of DuneEntityIt (it would be
easily read from the DuneEntityIt::Base typedef, but, alas, this
typedef is private...).

C++ includes: concrete_range_entity_iterator.hpp ";

%feature("docstring")
Bempp::ConcreteRangeEntityIterator::ConcreteRangeEntityIterator "

Constructor. The iterator will go over the range [ begin, end). ";

%feature("docstring")  Bempp::ConcreteRangeEntityIterator::next "

Increment iterator. ";

%feature("docstring")  Bempp::ConcreteRangeEntityIterator::entity "

Read-only access to the entity referenced by the iterator. ";

%feature("docstring")  Bempp::ConcreteRangeEntityIterator::frozen "

A stable pointer to the entity currently referenced by the iterator.

The returned pointer is guaranteed to keep referring to the same
entity even if the iterator is incremented or destroyed, as long as
the grid is not adapted and the grid object itself stays alive. ";


// File: classBempp_1_1ConcreteSubentityIterator.xml
%feature("docstring") Bempp::ConcreteSubentityIterator "

Iterator over the subentities of codimension codimSub of a given Dune
entity of type DuneEntity.

C++ includes: concrete_subentity_iterator.hpp ";

%feature("docstring")
Bempp::ConcreteSubentityIterator::ConcreteSubentityIterator "

Constructor.

Parameters:
-----------

dune_entity:   Entity whose subentities will be iterated over ";

%feature("docstring")  Bempp::ConcreteSubentityIterator::next "

Increment iterator. ";

%feature("docstring")  Bempp::ConcreteSubentityIterator::entity "

Read-only access to the entity referenced by the iterator. ";

%feature("docstring")  Bempp::ConcreteSubentityIterator::frozen "

A stable pointer to the entity currently referenced by the iterator.

The returned pointer is guaranteed to keep referring to the same
entity even if the iterator is incremented or destroyed, as long as
the grid is not adapted and the grid object itself stays alive. ";


// File: classBempp_1_1ConcreteVtkWriter.xml
%feature("docstring") Bempp::ConcreteVtkWriter "

Wrapper of a Dune VTK writer for a grid view of type DuneGridView.

C++ includes: concrete_vtk_writer.hpp ";

%feature("docstring")  Bempp::ConcreteVtkWriter::clear "

Clear the list of registered functions. ";

%feature("docstring")  Bempp::ConcreteVtkWriter::write "

Write output (interface might change later).

This method can be used in parallel as well as in serial programs. For
serial runs (commSize=1) it chooses other names without the
\"s####:p####:\" prefix for the .vtu/.vtp files and omits writing of
the .pvtu/pvtp file however. For parallel runs (commSize > 1) it is
the same as a call to pwrite() with path=\"\" and extendpath=\"\".

Parameters:
-----------

name:  Basic name to write (may not contain a path).

type:  Type of output (e.g,, ASCII) (optional).

Name of the created file. ";

%feature("docstring")  Bempp::ConcreteVtkWriter::pwrite "

Write output (interface might change later).

\"pwrite\" means \"path write\" (i.e. write somewhere else than the
current directory). The \"p\" does not mean this method has a monopoly
on parallel writing, the regular write(const std::string &,
OutputType) method can do that just fine.

Parameters:
-----------

name:  Base name of the output files. This should not contain any
directory part or filename extensions. It will be used both for the
piece file of each process and the parallel collection file.

path:  Directory where to put the parallel collection (.pvtu/.pvtp)
file. If it is relative, it is taken relative to the current
directory.

extendpath:  Directory where to put the piece file (.vtu/.vtp) of this
process. If it is relative, it is taken relative to the directory
denoted by path.

type:  How to encode the data in the file.

Name of the created file.

Currently, extendpath may not be absolute unless path is absolute,
because that would require the value of the current directory.

Exceptions:
-----------

Dune::NotImplemented:  Extendpath is absolute but path is relative.

Dune::IOError:  Failed to open a file. ";


// File: classBempp_1_1Context.xml
%feature("docstring") Bempp::Context "

Assembly context.

This class manages the assembly of weak forms and evaluation of
potentials.

An assembly context consists of a quadrature strategy, which
determines the way integrals are calculated, and assembly options,
which control higher-level aspects of weak-form assembly, e.g. the use
or not of acceleration algorithms such as ACA and the level of
parallelism.

A call to the Context::getWeakForm() function returns the weak form of
the abstract boundary operator passed in the argument to this
function, assembled using the settings from the given Context. The
Context may store the weak form in an internal cache; see the
documentation of getWeakForm() for more details.

C++ includes: context.hpp ";

%feature("docstring")  Bempp::Context::Context "

Constructor.

Parameters:
-----------

quadStrategy:  Quadrature strategy to be used for calculation of
integrals occurring e.g. in the weak forms of boundary operators or in
the definition of potential operators.

assemblyOptions:  Further options influencing the weak-form assembly
process. ";

%feature("docstring")  Bempp::Context::getWeakForm "

Return the weak form of the specified abstract operator.

This function returns returns the weak form of the specified abstract
boundary operator, calculated in accordance with the settings
specified during the construction of the Context.

An important design principle in BEM++ is that abstract boundary
operators are immutable after construction. The same is true for
Context objects. Therefore, a Context stores newly calculated weak
forms in an internal cache, unless a given abstract boundary operator
does not provide a valid unique identifier (see
AbstractBoundaryOperator::id()). As long as the weak form remains in
cache, subsequent calls to Context::getWeakForm() with the same
abstract boundary operator will not recalculate the weak form, but
return the cached instance. It should, however, be noted that the
cache does not maintain a persistent relationship with weak forms: it
stores them as weak rather than shared pointers. Therefore, a weak
form is deallocated as soon as the last reference to it *apart from
that residing in the cache* goes out of scope. ";

%feature("docstring")  Bempp::Context::assemblyOptions "

Return a reference to a copy of the AssemblyOptions object passed when
constructing the Context. ";

%feature("docstring")  Bempp::Context::quadStrategy "

Return a reference to the QuadratureStrategy object passed when
constructing the Context. ";


// File: structBempp_1_1ConvergenceTestMode.xml
%feature("docstring") Bempp::ConvergenceTestMode "";


// File: classBempp_1_1DefaultDirectSolver.xml
%feature("docstring") Bempp::DefaultDirectSolver "

Default Interface to the solution of boundary integral equations using
a dense LU decomposition.

This class provides an interface to the direct solution of boundary
integral equations using standard LU. It is implemented via a call to
theArmadillo dense solver, which is an interface to the corresponding
Lapack routines.

C++ includes: default_direct_solver.hpp ";

%feature("docstring")  Bempp::DefaultDirectSolver::DefaultDirectSolver
"

Construct a solver for a non-blocked boundary operator. ";

%feature("docstring")  Bempp::DefaultDirectSolver::DefaultDirectSolver
"

Construct a solver for a blocked boundary operator. ";

%feature("docstring")
Bempp::DefaultDirectSolver::~DefaultDirectSolver "";


// File: classBempp_1_1DefaultIterativeSolver.xml
%feature("docstring") Bempp::DefaultIterativeSolver "

Default Interface to the Belos Iterative solver package from Trilinos.

This class provides an interface to various iterative solvers
available via the Stratimikos Interface to Belos of Trilinos
(seeStratimikos documentation). Convergence can be tested either in
range space or in the dual space to the range space. A standard
Galerkin discretisation of the form $Ax=b$, maps into the dual space
of the range of the operator. By choosing to test in the range space
the equation $M^\\\\dagger Ax=M^\\\\dagger b$ is solved, where $M$ is
the mass matrix, mapping from the range space into its dual and
$M^\\\\dagger$ is its pseudoinverse.

C++ includes: default_iterative_solver.hpp ";

%feature("docstring")
Bempp::DefaultIterativeSolver::DefaultIterativeSolver "

Constructor of the  DefaultIterativeSolver class.

Parameters:
-----------

boundaryOp:  Non-blocked boundary operator.

mode:  Convergence test mode. Default:
TEST_CONVERGENCE_IN_DUAL_TO_RANGE ";

%feature("docstring")
Bempp::DefaultIterativeSolver::DefaultIterativeSolver "

Constructor of the  DefaultIterativeSolver class.

Parameters:
-----------

boundaryOp:  Blocked boundary operator

mode:  Convergence test mode. Default:
TEST_CONVERGENCE_IN_DUAL_TO_RANGE ";

%feature("docstring")
Bempp::DefaultIterativeSolver::~DefaultIterativeSolver "";

%feature("docstring")
Bempp::DefaultIterativeSolver::setPreconditioner "

Define a preconditioner.

The preconditioner is passed on to the Belos Solver.

Parameters:
-----------

preconditioner:  ";

%feature("docstring")  Bempp::DefaultIterativeSolver::initializeSolver
"

Initialize the parameters of the Belos iterative solver.

Parameters:
-----------

paramList:  Parameter lists can be read in as xml files or defined in
code. For default parameter lists for Gmres and Cg see
defaultGmresParameterList and defaultCgParameterList. ";


// File: classBempp_1_1DiscreteAcaBoundaryOperator.xml
%feature("docstring") Bempp::DiscreteAcaBoundaryOperator "

Discrete linear operator stored as a H-matrix.

C++ includes: discrete_aca_boundary_operator.hpp ";

%feature("docstring")
Bempp::DiscreteAcaBoundaryOperator::DiscreteAcaBoundaryOperator "

Constructor. ";

%feature("docstring")  Bempp::DiscreteAcaBoundaryOperator::asMatrix "

Matrix representation of the operator.

The default implementation is slow and should be overridden where
possible. ";

%feature("docstring")  Bempp::DiscreteAcaBoundaryOperator::rowCount "

Number of rows of the operator. ";

%feature("docstring")  Bempp::DiscreteAcaBoundaryOperator::columnCount
"

Number of columns of the operator. ";

%feature("docstring")  Bempp::DiscreteAcaBoundaryOperator::addBlock "

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::DiscreteAcaBoundaryOperator::asDiscreteAcaBoundaryOperator "

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")
Bempp::DiscreteAcaBoundaryOperator::makeAllMblocksDense "

Uncompress all blocks of the H-matrix and store them as dense
matrices.

Sometimes useful for debugging. ";

%feature("docstring")  Bempp::DiscreteAcaBoundaryOperator::domain "";

%feature("docstring")  Bempp::DiscreteAcaBoundaryOperator::range "";


// File: classBempp_1_1DiscreteBlockedBoundaryOperator.xml
%feature("docstring") Bempp::DiscreteBlockedBoundaryOperator "

Discrete boundary operator composed of multiple blocks stored
separately.

This class represents a linear operator whose matrix \\\\[ L =
\\\\begin{bmatrix} L_{11} & L_{12} & \\\\dots & L_{1n} \\\\\\\\ L_{21}
& L_{22} & \\\\dots & L_{2n} \\\\\\\\ \\\\vdots & \\\\vdots &
\\\\ddots & \\\\vdots \\\\\\\\ L_{m1} & L_{m2} & \\\\dots & L_{mn}
\\\\end{bmatrix} \\\\] is composed of $m \\\\times n$ discrete
boundary operators $L_{ij}$.

C++ includes: discrete_blocked_boundary_operator.hpp ";

%feature("docstring")
Bempp::DiscreteBlockedBoundaryOperator::DiscreteBlockedBoundaryOperator
"

Constructor.

Parameters:
-----------

blocks:  2D array of shared pointers to the discrete boundary
operators $L_{ij}$ making up the newly constructed blocked operator. A
null shared pointer is equivalent to a discrete boundary operator with
zero matrix.

rowCounts:   Vector whose ith element is the number of rows of the
matrix of each operator in ith row of the array blocks.

columnCounts:   Vector whose ith element is the number of columns of
the matrix of each operator in ith column of the array blocks. ";

%feature("docstring")
Bempp::DiscreteBlockedBoundaryOperator::rowCount "

Number of rows of the operator. ";

%feature("docstring")
Bempp::DiscreteBlockedBoundaryOperator::columnCount "

Number of columns of the operator. ";

%feature("docstring")
Bempp::DiscreteBlockedBoundaryOperator::addBlock "

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::DiscreteBlockedBoundaryOperator::asDiscreteAcaBoundaryOperator
"

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")  Bempp::DiscreteBlockedBoundaryOperator::domain
"";

%feature("docstring")  Bempp::DiscreteBlockedBoundaryOperator::range "";


// File: classBempp_1_1DiscreteBoundaryOperator.xml
%feature("docstring") Bempp::DiscreteBoundaryOperator "

Discrete boundary operator.

This class represents a discretised boundary operator, i.e. a matrix
$\\\\mathsf{L}$ with entries \\\\[ \\\\mathsf{L}_{mn} \\\\equiv
\\\\int_S \\\\phi^*_m(x) \\\\,[L\\\\, \\\\psi_n](x)\\\\,
\\\\mathrm{d}S(x), \\\\] where $L$ is a boundary operator,
$\\\\{\\\\phi_m\\\\}_{m=1}^{M}$ are the basis functions spanning a
*test space* and defined on a surface $S$, whereas
$\\\\{\\\\psi_n\\\\}_{n=1}^{N}$ are the basis functions of a *trial
space*. The way the matrix is stored can be arbitrary. Concrete
subclasses of this class implement specific storage methods.

If BEM++ is compiled with Trilinos, this class is derived from
Thyra::LinearOpDefaultBase<ValueType> and hence inherits all non-
private member function of this class; seeTrilinos documentation for
full documentation of these functions.

If Trilinos is not available during compilation, a simple fallback
interface is provided.

ValueType Type used to represent entries of the operator matrix. It
can take the following values: float, double, std::complex<float> and
std::complex<double>.

C++ includes: discrete_boundary_operator.hpp ";

%feature("docstring")
Bempp::DiscreteBoundaryOperator::~DiscreteBoundaryOperator "

Destructor. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperator::apply "

Apply the linear operator to a multivector.

Set the elements of the multivector y_inout to

y_inout := alpha * trans(L) * x_in + beta * y_inout,

where L is the linear operator represented by this object.

Parameters:
-----------

trans:  Determines whether what is applied is the \"bare\" operator,
its transpose, conjugate or conjugate transpose.

x_in:  The right-hand-side multivector.

y_inout:  The target multivector being transformed. When beta == 0.0,
this multivector can have uninitialized elements.

alpha:  Scalar multiplying this operator.

beta:  The multiplier for the target multivector y_inout.

This overload of the apply() member function is only available if the
library was compiled with Trilinos. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperator::apply "

Apply the operator to a vector.

Set the elements of the column vector y_inout to

y_inout := alpha * trans(L) * x_in + beta * y_inout,

where L is the linear operator represented by this object.

Parameters:
-----------

trans:  Determines whether what is applied is the \"bare\" operator,
its transpose, conjugate or conjugate transpose.

x_in:  The right-hand-side multivector.

y_inout:  The target multivector being transformed. When beta == 0.0,
this multivector can have uninitialized elements.

alpha:  Scalar multiplying this operator.

beta:  The multiplier for the target multivector y_inout.

This overload is always available, even if the library was compiled
without Trilinos. ";

%feature("docstring")
Bempp::DiscreteBoundaryOperator::asDiscreteAcaBoundaryOperator "

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperator::dump "

Write a textual representation of the operator to standard output.

The default implementation prints the matrix returned by asMatrix().
";

%feature("docstring")  Bempp::DiscreteBoundaryOperator::asMatrix "

Matrix representation of the operator.

The default implementation is slow and should be overridden where
possible. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperator::rowCount "

Number of rows of the operator. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperator::columnCount "

Number of columns of the operator. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperator::addBlock "

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";


// File: classBempp_1_1DiscreteBoundaryOperatorCache.xml
%feature("docstring") Bempp::DiscreteBoundaryOperatorCache "

Cache of discrete boundary operators.

C++ includes: discrete_boundary_operator_cache.hpp ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorCache::DiscreteBoundaryOperatorCache "

Constructor. ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorCache::getWeakForm "

Return the weak form of the operator op.

This function first checks whether the weak form of op is already
stored in the DiscreteBoundaryOperatorCache object. If it is, it is
returned. Otherwise the weak form is assembled from scratch, possible
stored in cache (if the operator op is cacheable) and returned to the
caller. ";


// File: classBempp_1_1DiscreteBoundaryOperatorComposition.xml
%feature("docstring") Bempp::DiscreteBoundaryOperatorComposition "

Composition (product) of discrete linear operators stored separately.

C++ includes: discrete_boundary_operator_composition.hpp ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorComposition::DiscreteBoundaryOperatorComposition
"

Constructor.

Construct a discrete operator representing the product of the
operators outer and inner (in this order).

The operators must be non-null and have compatible dimensions (
outer-> columnCount() == inner-> rowCount()), otherwise a
std::invalid_argument exception is thrown. ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorComposition::rowCount "

Number of rows of the operator. ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorComposition::columnCount "

Number of columns of the operator. ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorComposition::addBlock "

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorComposition::asDiscreteAcaBoundaryOperator
"

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorComposition::domain "";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorComposition::range "";


// File: classBempp_1_1DiscreteBoundaryOperatorSum.xml
%feature("docstring") Bempp::DiscreteBoundaryOperatorSum "

Sum of discrete linear operators stored separately.

C++ includes: discrete_boundary_operator_sum.hpp ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorSum::DiscreteBoundaryOperatorSum "

Constructor.

Construct a discrete operator representing the sum of the operators
term1 and term2.

Both operators must be non-null and have identical dimensions,
otherwise a std::invalid_argument exception is thrown. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperatorSum::asMatrix "

Matrix representation of the operator.

The default implementation is slow and should be overridden where
possible. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperatorSum::rowCount "

Number of rows of the operator. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperatorSum::columnCount
"

Number of columns of the operator. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperatorSum::addBlock "

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::DiscreteBoundaryOperatorSum::asDiscreteAcaBoundaryOperator "

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")  Bempp::DiscreteBoundaryOperatorSum::domain "";

%feature("docstring")  Bempp::DiscreteBoundaryOperatorSum::range "";


// File: classBempp_1_1DiscreteDenseBoundaryOperator.xml
%feature("docstring") Bempp::DiscreteDenseBoundaryOperator "

Discrete boundary operator stored as a dense matrix.

C++ includes: discrete_dense_boundary_operator.hpp ";

%feature("docstring")
Bempp::DiscreteDenseBoundaryOperator::DiscreteDenseBoundaryOperator "

Constructor.

Construct a discrete boundary operator represented by the matrix mat.
";

%feature("docstring")  Bempp::DiscreteDenseBoundaryOperator::dump "

Write a textual representation of the operator to standard output.

The default implementation prints the matrix returned by asMatrix().
";

%feature("docstring")  Bempp::DiscreteDenseBoundaryOperator::asMatrix
"

Matrix representation of the operator.

The default implementation is slow and should be overridden where
possible. ";

%feature("docstring")  Bempp::DiscreteDenseBoundaryOperator::rowCount
"

Number of rows of the operator. ";

%feature("docstring")
Bempp::DiscreteDenseBoundaryOperator::columnCount "

Number of columns of the operator. ";

%feature("docstring")  Bempp::DiscreteDenseBoundaryOperator::addBlock
"

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::DiscreteDenseBoundaryOperator::asDiscreteAcaBoundaryOperator "

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")  Bempp::DiscreteDenseBoundaryOperator::domain "";

%feature("docstring")  Bempp::DiscreteDenseBoundaryOperator::range "";


// File: classBempp_1_1DiscreteInverseSparseBoundaryOperator.xml
%feature("docstring") Bempp::DiscreteInverseSparseBoundaryOperator "

Discrete boundary operator stored as an inverse of a sparse matrix.

C++ includes: discrete_inverse_sparse_boundary_operator.hpp ";

%feature("docstring")
Bempp::DiscreteInverseSparseBoundaryOperator::DiscreteInverseSparseBoundaryOperator
"

Constructor.

Parameters:
-----------

mat:  Sparse matrix whose inverse will be represented by the newly
constructed operator. Must not be null.

symmetry:  Symmetry of the matrix. May be any combination of flags
defined in the Symmetry enumeration type. ";

%feature("docstring")
Bempp::DiscreteInverseSparseBoundaryOperator::~DiscreteInverseSparseBoundaryOperator
"";

%feature("docstring")
Bempp::DiscreteInverseSparseBoundaryOperator::rowCount "

Number of rows of the operator. ";

%feature("docstring")
Bempp::DiscreteInverseSparseBoundaryOperator::columnCount "

Number of columns of the operator. ";

%feature("docstring")
Bempp::DiscreteInverseSparseBoundaryOperator::addBlock "

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::DiscreteInverseSparseBoundaryOperator::domain "";

%feature("docstring")
Bempp::DiscreteInverseSparseBoundaryOperator::range "";

%feature("docstring")
Bempp::DiscreteInverseSparseBoundaryOperator::asDiscreteAcaBoundaryOperator
"

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";


// File: classBempp_1_1DiscreteSparseBoundaryOperator.xml
%feature("docstring") Bempp::DiscreteSparseBoundaryOperator "

Discrete boundary operator stored as a sparse matrix.

C++ includes: discrete_sparse_boundary_operator.hpp ";

%feature("docstring")
Bempp::DiscreteSparseBoundaryOperator::DiscreteSparseBoundaryOperator
"

Constructor.

Parameters:
-----------

mat:  Sparse matrix that will be represented by the newly constructed
operator. Must not be null.

symmetry:  Symmetry of the matrix. May be any combination of flags
defined in the Symmetry enumeration type.

trans:  If different from NO_TRANSPOSE, the discrete operator will
represent a transposed and/or complex-conjugated matrix mat. ";

%feature("docstring")  Bempp::DiscreteSparseBoundaryOperator::dump "

Write a textual representation of the operator to standard output.

The default implementation prints the matrix returned by asMatrix().
";

%feature("docstring")  Bempp::DiscreteSparseBoundaryOperator::asMatrix
"

Matrix representation of the operator.

The default implementation is slow and should be overridden where
possible. ";

%feature("docstring")  Bempp::DiscreteSparseBoundaryOperator::rowCount
"

Number of rows of the operator. ";

%feature("docstring")
Bempp::DiscreteSparseBoundaryOperator::columnCount "

Number of columns of the operator. ";

%feature("docstring")  Bempp::DiscreteSparseBoundaryOperator::addBlock
"

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::DiscreteSparseBoundaryOperator::asDiscreteAcaBoundaryOperator "

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")
Bempp::DiscreteSparseBoundaryOperator::epetraMatrix "

Return a shared pointer to the sparse matrix stored within this
operator.

The discrete operator represents the matrix returned by this function
*and possibly transposed and/or complex-conjugated*, depending on the
value returned by transpositionMode(). ";

%feature("docstring")
Bempp::DiscreteSparseBoundaryOperator::transpositionMode "

Return the active sparse matrix transformation.

Indicates whether this operator represents the unmodified sparse
matrix passed in the constructor or its transformation (transposition
and/or conjugation). ";

%feature("docstring")  Bempp::DiscreteSparseBoundaryOperator::domain "";

%feature("docstring")  Bempp::DiscreteSparseBoundaryOperator::range "";


// File: classBempp_1_1ElementaryAbstractBoundaryOperator.xml
%feature("docstring") Bempp::ElementaryAbstractBoundaryOperator "

Linear operator whose weak form can be constructed with a single
assembler.

The distinction between elementary and \"non-elementary\" linear
operators is purely technical. An operator is considered elementary if
its weak form can be constructed using a single instance of a subclass
of Fiber::LocalAssemblerForOperators. Currently this is possible for
the identity operator and for integral operators as defined in the
documentation of ElementaryIntegralOperator.

C++ includes: elementary_abstract_boundary_operator.hpp ";

%feature("docstring")
Bempp::ElementaryAbstractBoundaryOperator::ElementaryAbstractBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";

%feature("docstring")
Bempp::ElementaryAbstractBoundaryOperator::~ElementaryAbstractBoundaryOperator
"

Destructor. ";

%feature("docstring")
Bempp::ElementaryAbstractBoundaryOperator::makeAssembler "

Construct a local assembler suitable for this operator.

Parameters:
-----------

quadStrategy:  Quadrature strategy to be used to construct the
assembler.

(TODO: finish description of the other parameters.) ";

%feature("docstring")
Bempp::ElementaryAbstractBoundaryOperator::makeAssembler "

Construct a local assembler suitable for this operator using a
specified quadrature strategy.

Parameters:
-----------

quadStrategy:  Quadrature strategy to be used to construct the
assembler.

options:  Assembly options.

This is an overloaded function, provided for convenience. It
automatically constructs most of the arguments required by the other
overload. ";

%feature("docstring")
Bempp::ElementaryAbstractBoundaryOperator::assembleWeakFormInternal "

Assemble the operator's weak form using a specified local assembler.

This function is intended for internal use of the library. End users
should not need to call it directly. They should use
AbstractBoundaryOperator::assembleDetachedWeakForm() instead. ";


// File: classBempp_1_1ElementaryIntegralOperator.xml
%feature("docstring") Bempp::ElementaryIntegralOperator "

Elementary integral boundary operator.

This class represents an integral boundary operator $\\\\mathcal A$
whose weak form is \\\\[ \\\\langle \\\\phi, \\\\mathcal A \\\\psi
\\\\rangle \\\\equiv \\\\int_\\\\Gamma \\\\int_\\\\Gamma F[\\\\phi(x),
\\\\psi(y)] \\\\, d\\\\Gamma(x) \\\\, d\\\\Gamma(y), \\\\] where
$\\\\Gamma$ is a surface embedded in a space of dimension higher by
one and the integrand $F[\\\\phi(x), \\\\psi(y)]$ is an arbitrary
bilinear (or sesquilinear) form of the *test function* $\\\\phi$
belonging to the space dual to the range of $\\\\mathcal A$ and the
*trial function* $\\\\psi$ belonging to the domain of $\\\\mathcal A$.
In the simplest and most common case, $F[\\\\phi(x), \\\\psi(y)]$ is
just \\\\[ F[\\\\phi(x), \\\\psi(y)] = \\\\phi^*(x) K(x, y)
\\\\psi(y), \\\\] where $K(x, y)$ is a *kernel function* and the
asterisk denotes complex conjugation. For more complex operators, $F$
might involve some transformations of the test and trial functions
(e.g. their surface divergence or curl), the kernel function might be
a tensor, or $F$ might consist of several terms. The exact form of $F$
for a particular boundary operator is determined by the implementation
of the virtual functions integral(), kernels(), testTransformations()
and trialTransformations().

BasisFunctionType_ Type of the values of the (components of the) basis
functions into which functions acted upon by the operator are
expanded.  KernelType_ Type of the values of the (components of the)
kernel functions occurring in the integrand of the operator.
ResultType_ Type used to represent elements of the weak form of the
operator.

All three template parameters can take the following values: float,
double, std::complex<float> and std::complex<double>. All types must
have the same precision: for instance, mixing float with
std::complex<double> is not allowed. If either BasisFunctionType_ or
KernelType_ is a complex type, then ResultType_ must be set to the
same type.

C++ includes: elementary_integral_operator.hpp ";

%feature("docstring")
Bempp::ElementaryIntegralOperator::ElementaryIntegralOperator "

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";

%feature("docstring")  Bempp::ElementaryIntegralOperator::isLocal "

Return false. ";

%feature("docstring")  Bempp::ElementaryIntegralOperator::isRegular "

Return whether applying this operator to a regular function yields a
regular integral. ";


// File: classBempp_1_1ElementaryPotentialOperator.xml
%feature("docstring") Bempp::ElementaryPotentialOperator "

Elementary potential operator.

This class provides the interface for evaluation of a potential $k(x)$
defined by the formula

\\\\[ k(x) = \\\\int_\\\\Gamma F[x, \\\\psi(y)] \\\\,
\\\\mathrm{d}\\\\Gamma, \\\\]

where the integration goes over a surface $\\\\Gamma$ and the
integrand $F$ depends on the coordinates of a point $x$ lying outside
$\\\\Gamma$ and a surface charge distribution $\\\\psi(y)$ does not
lie on $\\\\Gamma$. In the simplest and most common case, $F[x,
\\\\psi(y)]$ is just \\\\[ F[x, \\\\psi(y)] = K(x, y) \\\\psi(y),
\\\\]

where $K(x, y)$ is a *kernel function*. For more complex operators,
$F$ might involve some transformations of the charge distribution
(e.g. its surface divergence or curl), the kernel function might be a
tensor, or $F$ might consist of several terms. The form of $F$ for a
particular potential operator is determined by the implementation of
the virtual functions integral(), kernels() and
chargeTransformations().

BasisFunctionType_ Type of the values of the (components of the) basis
functions into which functions acted upon by the operator are
expanded.  KernelType_ Type of the values of the (components of the)
kernel functions occurring in the integrand of the operator.
ResultType_ Type of the values of the (components of the) potential.

All three template parameters can take the following values: float,
double, std::complex<float> and std::complex<double>. All types must
have the same precision: for instance, mixing float with
std::complex<double> is not allowed. If either BasisFunctionType_ or
KernelType_ is a complex type, then ResultType_ must be set to the
same type.

C++ includes: elementary_potential_operator.hpp ";

%feature("docstring")
Bempp::ElementaryPotentialOperator::evaluateOnGrid "";

%feature("docstring")
Bempp::ElementaryPotentialOperator::evaluateAtPoints "";


// File: classBempp_1_1ElementaryRegularIntegralOperator.xml
%feature("docstring") Bempp::ElementaryRegularIntegralOperator "

Elementary boundary integral operator with weak form whose integrand
is a regular function.

C++ includes: elementary_regular_integral_operator.hpp ";

%feature("docstring")
Bempp::ElementaryRegularIntegralOperator::ElementaryRegularIntegralOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";

%feature("docstring")
Bempp::ElementaryRegularIntegralOperator::isRegular "

Return whether applying this operator to a regular function yields a
regular integral. ";


// File: classBempp_1_1ElementarySingularIntegralOperator.xml
%feature("docstring") Bempp::ElementarySingularIntegralOperator "

Elementary boundary integral operator with weak form whose integrand
has a singularity at origin.

C++ includes: elementary_singular_integral_operator.hpp ";

%feature("docstring")
Bempp::ElementarySingularIntegralOperator::ElementarySingularIntegralOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";

%feature("docstring")
Bempp::ElementarySingularIntegralOperator::isRegular "

Return whether applying this operator to a regular function yields a
regular integral. ";


// File: classBempp_1_1Entity.xml
%feature("docstring") Bempp::Entity "

Abstract wrapper of an entity of codimension codim.

C++ includes: entity.hpp ";

%feature("docstring")  Bempp::Entity::~Entity "

Destructor. ";

%feature("docstring")  Bempp::Entity::level "

Entity level. ";

%feature("docstring")  Bempp::Entity::geometry "

Reference to the geometry of this entity.

This object gives, among other things, the map from a reference
element to world coordinates.

Be careful when storing such references. If the state of any object is
changed, e.g. an iterator is advanced, there is no guarantee that the
reference remains valid. ";

%feature("docstring")  Bempp::Entity::type "

Type of the reference element.

The type can be used to access the Dune::GenericReferenceElement. ";


// File: classBempp_1_1Entity_3_010_01_4.xml
%feature("docstring") Bempp::Entity< 0 > "

Abstract wrapper of an entity of codimension 0.

C++ includes: entity.hpp ";

/*  Methods shared by entities of all codimensions  */

%feature("docstring")  Bempp::Entity< 0 >::level "

Entity level ";

%feature("docstring")  Bempp::Entity< 0 >::geometry "

Reference to the geometry of this entity.

This object gives, among other things, the map from a reference
element to world coordinates.

Be careful when storing such references. If the state of any object is
changed, e.g. an iterator is advanced, there is no guarantee that the
reference remains valid. ";

%feature("docstring")  Bempp::Entity< 0 >::type "

Type of the reference element.

The type can be used to access the Dune::GenericReferenceElement. ";

/*  Extended interface of entities of codimension 0  */

%feature("docstring")  Bempp::Entity< 0 >::subEntityCount "

Number of subentities of codimension codimSub.

This method is in principle redundant because this information can be
obtained via the reference element of the geometry. It is there for
efficiency reasons and to make the interface self-contained. ";

%feature("docstring")  Bempp::Entity< 0 >::subEntityIterator "

Iterator over subentities of codimension codimSub.

codimSub must be greater than 0 and less than the dimension of the
grid. ";

%feature("docstring")  Bempp::Entity< 0 >::father "

Inter-level access to father entity on the next-coarser grid.

The given entity resulted directly from a subdivision of its father
entity. For macro (level-0) elements a null unique_ptr is returned.

If the partitionType of the Entity is GhostEntity, it is not
guaranteed that this method is working or implemented in general. For
some grids it might be available, though. ";

%feature("docstring")  Bempp::Entity< 0 >::hasFather "

True if entity has a father entity which can be accessed using the
father() method. ";

%feature("docstring")  Bempp::Entity< 0 >::isLeaf "

True if the entity is contained in the leaf grid. ";

%feature("docstring")  Bempp::Entity< 0 >::isRegular "

True if the element is of regular type in red/green type refinement.

In bisection or hanging node refinement this is always true. ";

%feature("docstring")  Bempp::Entity< 0 >::sonIterator "

Inter-level access to elements that resulted from (recursive)
subdivision of this element.

Parameters:
-----------

maxlevel:  Iterator does not stop at elements with level greater than
maxlevel.

Iterator to the first son (level is not greater than maxlevel)

If the partitionType of the Entity is GhostEntity, it is not
guaranteed that this method is working or implemented in general. For
some grids it might be available, though. ";

%feature("docstring")  Bempp::Entity< 0 >::isNew "

True if the entity has been created during the last call to adapt().
";

%feature("docstring")  Bempp::Entity< 0 >::mightVanish "

True if the entity might disappear during the next call to adapt().

If the method returns false, the entity is guaranteed to still be
present after adaptation. ";

/*  Internal methods  */

%feature("docstring")  Bempp::Entity< 0 >::~Entity "

Destructor. ";


// File: classBempp_1_1EntityIterator.xml
%feature("docstring") Bempp::EntityIterator "

Abstract base class for iterators over entities.

Parameters:
-----------

codim:  Codimension of the entities iterated over.

Typical usage (here ConcreteEntityIterator is some subclass of
EntityIterator<codim>):

C++ includes: entity_iterator.hpp ";

%feature("docstring")  Bempp::EntityIterator::next "

Increment iterator. ";

%feature("docstring")  Bempp::EntityIterator::finished "

True if iterator points past the end of the iteration range. ";

%feature("docstring")  Bempp::EntityIterator::entity "

Read-only access to the entity referenced by the iterator. ";

%feature("docstring")  Bempp::EntityIterator::frozen "

A stable pointer to the entity currently referenced by the iterator.

The returned pointer is guaranteed to keep referring to the same
entity even if the iterator is incremented or destroyed, as long as
the grid is not adapted and the grid object itself stays alive. ";


// File: classBempp_1_1EntityPointer.xml
%feature("docstring") Bempp::EntityPointer "

Abstract base class for an object providing read-only access to an
entity of codimension codim.

C++ includes: entity_pointer.hpp ";

%feature("docstring")  Bempp::EntityPointer::~EntityPointer "

Destructor. ";

%feature("docstring")  Bempp::EntityPointer::entity "

Read-only access to the underlying entity. ";


// File: classBempp_1_1EvaluationOptions.xml
%feature("docstring") Bempp::EvaluationOptions "

Options controlling evaluation of potentials.

C++ includes: evaluation_options.hpp ";

%feature("docstring")  Bempp::EvaluationOptions::EvaluationOptions "

Constructor. ";

%feature("docstring")  Bempp::EvaluationOptions::setMaxThreadCount "

Set the maximum number of threads used during evaluation of
potentials.

maxThreadCount must be a positive number or AUTO. In the latter case
the number of threads is determined automatically. ";

%feature("docstring")  Bempp::EvaluationOptions::switchToTbb "

Set the maximum number of threads used during evaluation of
potentials.

Deprecated Use setMaxThreadCount() instead. ";

%feature("docstring")
Bempp::EvaluationOptions::parallelizationOptions "

Return current parallelization options. ";


// File: classBempp_1_1ExtendedBemCluster.xml
%feature("docstring") Bempp::ExtendedBemCluster "";

%feature("docstring")  Bempp::ExtendedBemCluster::ExtendedBemCluster "";

%feature("docstring")  Bempp::ExtendedBemCluster::clone "";

%feature("docstring")  Bempp::ExtendedBemCluster::isadm "";

%feature("docstring")  Bempp::ExtendedBemCluster::maximumBlockSize "";


// File: classBempp_1_1Geometry.xml
%feature("docstring") Bempp::Geometry "

Abstract wrapper of a geometry.

C++ includes: geometry.hpp ";

%feature("docstring")  Bempp::Geometry::~Geometry "

Destructor. ";

%feature("docstring")  Bempp::Geometry::dim "

Dimension of the geometry. ";

%feature("docstring")  Bempp::Geometry::dimWorld "

Dimension of the space containing the geometry. ";

%feature("docstring")  Bempp::Geometry::setup "

Set up geometry of an entity.

Parameters:
-----------

corners:  Coordinates of the entity's vertices, stored columnwise.

auxData:  Auxiliary data necessary for the description of the entity.
Interpretation of these data in subclasses of Geometry may vary. They
can be used for example to define a *curvilinear* element. ";

%feature("docstring")  Bempp::Geometry::setup "";

%feature("docstring")  Bempp::Geometry::type "

Type of the reference element.

The type can be used to access the Dune::GenericReferenceElement. ";

%feature("docstring")  Bempp::Geometry::affine "

True if the geometry mapping is affine and false otherwise. ";

%feature("docstring")  Bempp::Geometry::cornerCount "

Number of corners of the reference element.

Since a geometry is a convex polytope the number of corners is a well-
defined concept. The method is redundant because this information is
also available via the reference element. It is here for efficiency
and ease of use. ";

%feature("docstring")  Bempp::Geometry::getCorners "

Get the positions of the geometry corners.

Parameters:
-----------

c:  Matrix whose $i$th column contains the coordinates of the $i$th
corner. The numbering of corners follows the conventions of the
generic reference element. ";

%feature("docstring")  Bempp::Geometry::getCorners "";

%feature("docstring")  Bempp::Geometry::local2global "

Convert local (logical) to global (physical) coordinates.

Parameters:
-----------

local:  Matrix whose $i$th column contains the local coordinates of a
point $x_i \\\\in D$.

global:  Matrix whose $i$th column contains the global coordinates of
$x_i$, i.e. $g(x_i)$. ";

%feature("docstring")  Bempp::Geometry::local2global "";

%feature("docstring")  Bempp::Geometry::global2local "

Convert global (physical) to local (logical) coordinates.

Parameters:
-----------

global:  Matrix whose $i$th column contains the global coordinates of
a point $x_i \\\\in W$.

local:  Matrix whose $i$th column contains the local coordinates of
$x_i$, i.e. $g^{-1}(x_i)$.

This is going to be tricky to implement for dimGrid < dimWorld. Maybe
the docstring should say that we convert some sort of *projection* of
global to local. ";

%feature("docstring")  Bempp::Geometry::global2local "";

%feature("docstring")  Bempp::Geometry::getIntegrationElements "

Get the factor appearing in the integral transformation formula at
specified points.

Let $ g : D \\\\to W$ denote the transformation described by the
Geometry. Then the jacobian of the transformation is defined as the
$\\\\textrm{cdim}\\\\times\\\\textrm{mydim}$ matrix \\\\[ J_g(x) =
\\\\left( \\\\begin{array}{ccc} \\\\frac{\\\\partial g_0}{\\\\partial
x_0} & \\\\cdots & \\\\frac{\\\\partial g_0}{\\\\partial x_{n-1}}
\\\\\\\\ \\\\vdots & \\\\ddots & \\\\vdots \\\\\\\\
\\\\frac{\\\\partial g_{m-1}}{\\\\partial x_0} & \\\\cdots &
\\\\frac{\\\\partial g_{m-1}}{\\\\partial x_{n-1}} \\\\end{array}
\\\\right).\\\\] Here we abbreviated $m=\\\\textrm{cdim}$ and
$n=\\\\textrm{mydim}$ for readability.

The integration element $\\\\mu(x)$ for any $x\\\\in D$ is then
defined as \\\\[ \\\\mu(x) = \\\\sqrt{|\\\\det J_g^T(x)J_g(x)|}.\\\\]

Parameters:
-----------

local:  Matrix whose $i$th column contains the local coordinates of a
point $x_i \\\\in D$.

int_element:  Row vector whose $i$th entry contains the integration
element $\\\\mu(x_i)$.

Each implementation computes the integration element with optimal
efficiency. For example in an equidistant structured mesh it may be as
simple as $h^\\\\textrm{mydim}$. ";

%feature("docstring")  Bempp::Geometry::getIntegrationElements "";

%feature("docstring")  Bempp::Geometry::volume "

Volume of geometry. ";

%feature("docstring")  Bempp::Geometry::getCenter "

Get center of geometry.

Note that this method is still subject to a change of name and
semantics. At the moment, the center is not required to be the
centroid of the geometry, or even the centroid of its corners. This
makes acceptable the current default implementation, which maps the
centroid of the reference element to the geometry.

We may change the name (and semantic) of the method to centroid() if
Dune's developers find reasonably efficient ways to implement it
properly.

Parameters:
-----------

c:  Coordinates of the center of geometry. ";

%feature("docstring")  Bempp::Geometry::getCenter "";

%feature("docstring")  Bempp::Geometry::getJacobiansTransposed "

Get transposed Jacobian matrices at specified points.

The Jacobian matrix is defined in the documentation of
getIntegrationElements().

Parameters:
-----------

local:  Matrix whose $i$th column contains the local coordinates of a
point $x_i \\\\in D$.

jacobian_t:  3D array whose $i$th slice (i.e. jacobian_t(:,:,i))
contains the transposed Jacobian matrix at $x_i$, i.e. $J_g^T(x_i)$.
";

%feature("docstring")  Bempp::Geometry::getJacobiansTransposed "";

%feature("docstring")  Bempp::Geometry::getJacobianInversesTransposed
"

Get inverses of transposed Jacobian matrices at specified points.

The Jacobian matrix is defined in the documentation of
getIntegrationElements().

Parameters:
-----------

local:  Matrix whose $i$th column contains the local coordinates of a
point $x_i \\\\in D$.

jacobian_inv_t:  3D array whose $i$th slice (i.e.
jacobian_inv_t(:,:,i)) contains the inverse of the transposed Jacobian
matrix at $x_i$, i.e. $J_g^{-T}(x_i)$.

The use of this function is to compute the gradient of some function
$f : W \\\\to \\\\textbf{R}$ at some position $y=g(x)$, where $x\\\\in
D$ and $g$ the transformation of the Geometry. When we set
$\\\\hat{f}(x) = f(g(x))$ and apply the chain rule we obtain
\\\\[\\\\nabla f(g(x)) = J_g^{-T}(x) \\\\nabla \\\\hat{f}(x).\\\\]

In the non-symmetric case $\\\\textrm{cdim} \\\\neq
\\\\textrm{mydim}$, the pseudoinverse of $J_g^T(x)$ is returned. This
means that it is inverse for all tangential vectors in $g(x)$ while
mapping all normal vectors to zero. ";

%feature("docstring")  Bempp::Geometry::getJacobianInversesTransposed
"";

%feature("docstring")  Bempp::Geometry::getNormals "

Get unit vectors normal to the entity at specified points.

An exception is thrown if dim() != dimWorld() - 1.

Parameters:
-----------

local:  Matrix whose $i$th column contains the local coordinates of a
point $x_i \\\\in D$.

normal:  Matrix whose $i$th column containts components of a unit
vector normal to the entity at $x_i$. ";

%feature("docstring")  Bempp::Geometry::getNormals "";

%feature("docstring")  Bempp::Geometry::getData "";

%feature("docstring")  Bempp::Geometry::getData "";


// File: classBempp_1_1GeometryFactory.xml
%feature("docstring") Bempp::GeometryFactory "

Abstract geometry factory.

C++ includes: geometry_factory.hpp ";

%feature("docstring")  Bempp::GeometryFactory::~GeometryFactory "";

%feature("docstring")  Bempp::GeometryFactory::make "";


// File: classBempp_1_1Grid.xml
%feature("docstring") Bempp::Grid "

Abstract wrapper of a grid.

Functions related to parallelization are not wrapped yet.

C++ includes: grid.hpp ";

/*  Grid parameters  */

%feature("docstring")  Bempp::Grid::dim "

Dimension of the grid. ";

%feature("docstring")  Bempp::Grid::dimWorld "

Dimension of the space containing the grid. ";

%feature("docstring")  Bempp::Grid::maxLevel "

Maximum level defined in this grid.

Levels are numbered 0 ... maxLevel() with 0 the coarsest level. ";

%feature("docstring")  Bempp::Grid::boundarySegmentCount "

Number of boundary segments within the macro (level-0) grid. ";

/*  Views  */

%feature("docstring")  Bempp::Grid::levelView "

View of the entities on grid level level. ";

%feature("docstring")  Bempp::Grid::leafView "

View of the leaf entities. ";

%feature("docstring")  Bempp::Grid::topology "

Return the topology of the grid. ";

%feature("docstring")  Bempp::Grid::elementGeometryFactory "

Factory able to construct empty geometries of codimension 0 compatible
with this grid.

For internal use. Todo Provide implementations for other codimensions.
";

/*  Id sets  */

%feature("docstring")  Bempp::Grid::globalIdSet "

Reference to the grid's global id set. ";

%feature("docstring")  Bempp::Grid::~Grid "

Destructor. ";


// File: classBempp_1_1GridFactory.xml
%feature("docstring") Bempp::GridFactory "

Grid factory.

This class provides static member functions to construct grids on the
fly and to import grids from existing files.

C++ includes: grid_factory.hpp ";


// File: classBempp_1_1GridFunction.xml
%feature("docstring") Bempp::GridFunction "

Function defined on a grid.

This class represents a function defined on a grid and expanded in a
particular function space.

C++ includes: grid_function.hpp ";

%feature("docstring")  Bempp::GridFunction::GridFunction "

Constructor.

Construct an uninitialized grid function. The only way to initialize
it later is using the assignment operator. ";

%feature("docstring")  Bempp::GridFunction::GridFunction "

Constructor.

Parameters:
-----------

context:  Assembly context from which a quadrature strategy can be
retrieved.

space:  Function space to expand the grid function in.

dualSpace:  Function space dual to space.

data:  If dataType == COEFFICIENTS, the vector data should have length
space.globalDofCount() and contain the expansion coefficients of the
grid function in the space space. Otherwise, if dataType ==
PROJECTIONS, data should have length dualSpace.globalDofCount()
contain the scalar products of the grid function and the basis
functions of the space dualSpace.

dataType:  Interpretation of the vector passed via the argument data.

This constructor builds a grid function from either its coefficients
in a function space or from its projections on the basis functions of
another (dual) function space. If the other type of data turns out to
be needed later (for example, the projections vector if coefficients
were supplied in the constructor), it is calculated automatically. The
Context object given in the constructor is then used to determine the
strategy for evaluating any necessary integrals.

space and dualSpace must be defined on the same grid. ";

%feature("docstring")  Bempp::GridFunction::GridFunction "

Constructor.

Parameters:
-----------

context:  Assembly context from which a quadrature strategy can be
retrieved.

space:  Function space to expand the grid function in.

dualSpace:  Function space dual to space.

coefficients:   Vector of length space.globalDofCount() containing the
expansion coefficients of the grid function in the space space.

projections:   Vector of length dualSpace.globalDofCount() containing
the scalar products of the grid function and the basis functions of
the space dualSpace.

space and dualSpace must be defined on the same grid.

This constructor is mainly intended for internal use in BEM++. ";

%feature("docstring")  Bempp::GridFunction::GridFunction "

Constructor.

Parameters:
-----------

context:  Assembly context from which a quadrature strategy can be
retrieved.

space:  Function space to expand the grid function in.

dualSpace:  Function space dual to space.

function:  Function object whose values on space.grid() will be used
to construct the new grid function.

This constructor builds a grid function by approximating the function
function in the basis of space space.

space and dualSpace must be defined on the same grid. ";

%feature("docstring")  Bempp::GridFunction::isInitialized "

Return whether this function has been properly initialized. ";

%feature("docstring")  Bempp::GridFunction::grid "

Grid on which this function is defined.

An exception is thrown if this function is called on an uninitialized
GridFunction object. ";

%feature("docstring")  Bempp::GridFunction::space "

Space in which this function is expanded. ";

%feature("docstring")  Bempp::GridFunction::dualSpace "

Space dual to the space in which this function is expanded. ";

%feature("docstring")  Bempp::GridFunction::context "

Assembly context used to retrieve the strategy for evaluating any
necessary integrals. ";

%feature("docstring")  Bempp::GridFunction::componentCount "

Number of components of this function.

An exception is thrown if this function is called on an uninitialized
GridFunction object. ";

%feature("docstring")  Bempp::GridFunction::coefficients "

Vector of expansion coefficients of this function in the basis of its
primal space.

If the grid function was constructed from the vector of its
projections on the basis of its dual space, the expansion coefficients
in the primal space are calculated automatically on the first call to
coefficients() and cached internally before being returned.

An exception is thrown if this function is called on an uninitialized
GridFunction object (one constructed with the default constructor). ";

%feature("docstring")  Bempp::GridFunction::projections "

Vector of scalar products of this function with the basis functions of
its dual space.

If the grid function was constructed from the vector of its expansion
coefficients in its primal space, the projections on the basis
functions of its dual space are calculated automatically on the first
call to projections() and cached internally before being returned.

An exception is thrown if this function is called on an uninitialized
GridFunction object (one constructed with the default constructor). ";

%feature("docstring")  Bempp::GridFunction::setCoefficients "

Reset the expansion coefficients of this function in the basis of its
primal space.

As a side effect, any internally stored vector of the projections of
this grid function on the basis functions of its dual space is marked
as invalid and recalculated on the next call to projections(). ";

%feature("docstring")  Bempp::GridFunction::setProjections "

Reset the vector of scalar products of this function with the basis
functions of its dual space.

As a side effect, any internally stored vector of the coefficients of
this grid function in its primal space is marked as invalid and
recalculated on the next call to coefficients(). ";

%feature("docstring")  Bempp::GridFunction::L2Norm "

Return the $L^2$-norm of the grid function. ";

%feature("docstring")  Bempp::GridFunction::basis "";

%feature("docstring")  Bempp::GridFunction::getLocalCoefficients "

Retrieve the expansion coefficients of this function on a single
element.

Parameters:
-----------

element:  An element belonging to the grid space.grid().

coeffs:   Vector of the expansion coefficients of this function
corresponding to the basis functions of the primal space living on
element element.

The results of calling this function on an uninitialized GridFunction
object are undefined. ";

%feature("docstring")  Bempp::GridFunction::exportToVtk "

Export this function to a VTK file.

Parameters:
-----------

dataType:  Determines whether data are attaches to vertices or cells.

dataLabel:  Label used to identify the function in the VTK file.

fileNamesBase:  Base name of the output files. It should not contain
any directory part or filename extensions.

filesPath:  Output directory. Can be set to NULL, in which case the
files are output in the current directory.

type:  Output type (default: ASCII). See Dune reference manual for
more details.

An exception is thrown if this function is called on an uninitialized
GridFunction object. ";

%feature("docstring")  Bempp::GridFunction::evaluateAtSpecialPoints "

Evaluate function at either vertices or barycentres.

The results of calling this function on an uninitialized GridFunction
object are undefined. ";


// File: structBempp_1_1GridParameters.xml
%feature("docstring") Bempp::GridParameters "

Grid parameters.

This structure is used to specify parameters of grid constructed by
GridFactory.

C++ includes: grid_parameters.hpp ";


// File: classBempp_1_1GridView.xml
%feature("docstring") Bempp::GridView "

Abstract wrapper of a grid view.

C++ includes: grid_view.hpp ";

%feature("docstring")  Bempp::GridView::~GridView "

Destructor ";

%feature("docstring")  Bempp::GridView::indexSet "

The index set. ";

%feature("docstring")  Bempp::GridView::elementMapper "

The element mapper. ";

%feature("docstring")  Bempp::GridView::entityCount "

Number of entities with codimension codim. ";

%feature("docstring")  Bempp::GridView::entityCount "

Number of entities with geometry type type. ";

%feature("docstring")  Bempp::GridView::containsEntity "

True if the entity e of codimension 0 is contained in this grid view.

If e is not an element of the grid, then the result of
containsEntity() is undefined. ";

%feature("docstring")  Bempp::GridView::containsEntity "

True if the entity e of codimension 1 is contained in this grid view.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::GridView::containsEntity "

True if the entity e of codimension 2 is contained in this grid view.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::GridView::containsEntity "

True if the entity e of codimension 3 is contained in this grid view.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::GridView::entityIterator "

Iterator over entities of codimension codim contained in this view. ";

%feature("docstring")  Bempp::GridView::getRawElementData "

Get raw data describing the geometry of all codim-0 entities contained
in this grid view.

This method is mainly intended for use in the OpenCL implementation.

Parameters:
-----------

vertices:  On output, a 2D array whose (i,j)th element is the ith
coordinate of the vertex of index j.

elementCorners:  On output, a 2D array whose (i,j)th element is the
index of the ith corner of jth codim-0 entity, or -1 if this entity
has less than i-1 corners.

auxData:  Auxiliary data, to be used in future to describe the
geometry of curvilinear elements. Currently this argument is always
set to an empty matrix. ";

%feature("docstring")  Bempp::GridView::getRawElementData "";

%feature("docstring")  Bempp::GridView::reverseElementMapper "

Mapping from codim-0 entity index to entity pointer.

Note that this object is *not* updated when the grid is adapted. In
that case you need to create a new grid view and obtain a new
reference to the reverse element mapper. ";

%feature("docstring")  Bempp::GridView::vtkWriter "

Create a VtkWriter for this grid view.

Parameters:
-----------

dm:  Data mode (conforming or nonconforming; see the documentation of
Dune::VTK::DataMode for details). ";


// File: classBempp_1_1Helmholtz3dAdjointDoubleLayerBoundaryOperator.xml
%feature("docstring")
Bempp::Helmholtz3dAdjointDoubleLayerBoundaryOperator "

Adjoint double-layer-potential boundary operator for the Helmholtz
equation in 3D.

BasisFunctionType Type of the values of the basis functions into which
functions acted upon by the operator are expanded. It can take the
following values: float, double, std::complex<float> and
std::complex<double>.

See:   Helmholtz equation in 3D

C++ includes: helmholtz_3d_adjoint_double_layer_boundary_operator.hpp
";

%feature("docstring")
Bempp::Helmholtz3dAdjointDoubleLayerBoundaryOperator::Helmholtz3dAdjointDoubleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Helmholtz equation in 3D for its
definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1Helmholtz3dAdjointDoubleLayerBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::Helmholtz3dAdjointDoubleLayerBoundaryOperatorImpl "";

%feature("docstring")
Bempp::Helmholtz3dAdjointDoubleLayerBoundaryOperatorImpl::Helmholtz3dAdjointDoubleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1Helmholtz3dBoundaryOperatorBase.xml
%feature("docstring") Bempp::Helmholtz3dBoundaryOperatorBase "

Base class for boundary operators for the Helmholtz equation in 3D.

Impl Type of the internal implementation object.  BasisFunctionType
Type of the values of the basis functions into which functions acted
upon by the operator are expanded. It can take the following values:
float, double, std::complex<float> and std::complex<double>.

See:   Helmholtz equation in 3D

C++ includes: helmholtz_3d_boundary_operator_base.hpp ";

%feature("docstring")
Bempp::Helmholtz3dBoundaryOperatorBase::Helmholtz3dBoundaryOperatorBase
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Helmholtz equation in 3D for its
definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";

%feature("docstring")
Bempp::Helmholtz3dBoundaryOperatorBase::Helmholtz3dBoundaryOperatorBase
"

Copy constructor. ";

%feature("docstring")
Bempp::Helmholtz3dBoundaryOperatorBase::~Helmholtz3dBoundaryOperatorBase
"

Destructor. ";

%feature("docstring")
Bempp::Helmholtz3dBoundaryOperatorBase::waveNumber "

Return the wave number set previously in the constructor. ";

%feature("docstring")  Bempp::Helmholtz3dBoundaryOperatorBase::id "

Return the identifier of this operator.

Two boundary operators related to the Helmholtz equation are treated
as identical, and hence having the same weak form, if they have the
same C++ type (e.g. Helmholtz3dDoubleLayerBoundaryOperator<double>),
domain space, range space, space dual to range and wave number. ";


// File: classBempp_1_1Helmholtz3dBoundaryOperatorId.xml
%feature("docstring") Bempp::Helmholtz3dBoundaryOperatorId "";

%feature("docstring")
Bempp::Helmholtz3dBoundaryOperatorId::Helmholtz3dBoundaryOperatorId "";

%feature("docstring")  Bempp::Helmholtz3dBoundaryOperatorId::hash "";

%feature("docstring")  Bempp::Helmholtz3dBoundaryOperatorId::dump "";

%feature("docstring")  Bempp::Helmholtz3dBoundaryOperatorId::isEqual "";


// File: classBempp_1_1Helmholtz3dDoubleLayerBoundaryOperator.xml
%feature("docstring") Bempp::Helmholtz3dDoubleLayerBoundaryOperator "

Double-layer-potential boundary operator for the Helmholtz equation in
3D.

BasisFunctionType Type of the values of the basis functions into which
functions acted upon by the operator are expanded. It can take the
following values: float, double, std::complex<float> and
std::complex<double>.

See:   Helmholtz equation in 3D

C++ includes: helmholtz_3d_double_layer_boundary_operator.hpp ";

%feature("docstring")
Bempp::Helmholtz3dDoubleLayerBoundaryOperator::Helmholtz3dDoubleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Helmholtz equation in 3D for its
definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1Helmholtz3dDoubleLayerBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::Helmholtz3dDoubleLayerBoundaryOperatorImpl "";

%feature("docstring")
Bempp::Helmholtz3dDoubleLayerBoundaryOperatorImpl::Helmholtz3dDoubleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1Helmholtz3dDoubleLayerPotentialOperator.xml
%feature("docstring") Bempp::Helmholtz3dDoubleLayerPotentialOperator "

Double-layer potential operator for the Helmholtz equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded. It can take
the following values: float, double, std::complex<float> and
std::complex<double>.

See:   Helmholtz equation in 3D

C++ includes: helmholtz_3d_double_layer_potential_operator.hpp ";

%feature("docstring")
Bempp::Helmholtz3dDoubleLayerPotentialOperator::Helmholtz3dDoubleLayerPotentialOperator
"

Constructor.

Parameters:
-----------

waveNumber:  Wave number. See Helmholtz equation in 3D for its
definition. ";

%feature("docstring")
Bempp::Helmholtz3dDoubleLayerPotentialOperator::~Helmholtz3dDoubleLayerPotentialOperator
"

Destructor. ";


// File: structBempp_1_1Helmholtz3dDoubleLayerPotentialOperatorImpl.xml
%feature("docstring")
Bempp::Helmholtz3dDoubleLayerPotentialOperatorImpl "";

%feature("docstring")
Bempp::Helmholtz3dDoubleLayerPotentialOperatorImpl::Helmholtz3dDoubleLayerPotentialOperatorImpl
"";


// File: classBempp_1_1Helmholtz3dHypersingularBoundaryOperator.xml
%feature("docstring") Bempp::Helmholtz3dHypersingularBoundaryOperator
"

Hypersingular boundary operator for the Helmholtz equation in 3D.

BasisFunctionType Type of the values of the basis functions into which
functions acted upon by the operator are expanded. It can take the
following values: float, double, std::complex<float> and
std::complex<double>.

See:   Helmholtz equation in 3D

C++ includes: helmholtz_3d_hypersingular_boundary_operator.hpp ";

%feature("docstring")
Bempp::Helmholtz3dHypersingularBoundaryOperator::Helmholtz3dHypersingularBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Helmholtz equation in 3D for its
definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1Helmholtz3dHypersingularBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::Helmholtz3dHypersingularBoundaryOperatorImpl "";

%feature("docstring")
Bempp::Helmholtz3dHypersingularBoundaryOperatorImpl::Helmholtz3dHypersingularBoundaryOperatorImpl
"";


// File: classBempp_1_1Helmholtz3dPotentialOperatorBase.xml
%feature("docstring") Bempp::Helmholtz3dPotentialOperatorBase "

Base class for potential operators for the Helmholtz equation in 3D.

Impl Type of the internal implementation object.  BasisFunctionType_
Type of the values of the basis functions into which functions acted
upon by the operator are expanded. It can take the following values:
float, double, std::complex<float> and std::complex<double>.

See:   Helmholtz equation in 3D

C++ includes: helmholtz_3d_potential_operator_base.hpp ";

%feature("docstring")
Bempp::Helmholtz3dPotentialOperatorBase::Helmholtz3dPotentialOperatorBase
"

Constructor.

Parameters:
-----------

waveNumber:  Wave number. See Helmholtz equation in 3D for its
definition. ";

%feature("docstring")
Bempp::Helmholtz3dPotentialOperatorBase::Helmholtz3dPotentialOperatorBase
"

Copy constructor. ";

%feature("docstring")
Bempp::Helmholtz3dPotentialOperatorBase::~Helmholtz3dPotentialOperatorBase
"

Destructor. ";

%feature("docstring")
Bempp::Helmholtz3dPotentialOperatorBase::waveNumber "

Return the wave number set previously in the constructor. ";


// File: classBempp_1_1Helmholtz3dSingleLayerBoundaryOperator.xml
%feature("docstring") Bempp::Helmholtz3dSingleLayerBoundaryOperator "

Single-layer-potential boundary operator for the Helmholtz equation in
3D.

BasisFunctionType Type of the values of the basis functions into which
functions acted upon by the operator are expanded. It can take the
following values: float, double, std::complex<float> and
std::complex<double>.

See:   Helmholtz equation in 3D

C++ includes: helmholtz_3d_single_layer_boundary_operator.hpp ";

%feature("docstring")
Bempp::Helmholtz3dSingleLayerBoundaryOperator::Helmholtz3dSingleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Helmholtz equation in 3D for its
definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1Helmholtz3dSingleLayerBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::Helmholtz3dSingleLayerBoundaryOperatorImpl "";

%feature("docstring")
Bempp::Helmholtz3dSingleLayerBoundaryOperatorImpl::Helmholtz3dSingleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1Helmholtz3dSingleLayerPotentialOperator.xml
%feature("docstring") Bempp::Helmholtz3dSingleLayerPotentialOperator "

Single-layer potential operator for the Helmholtz equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded. It can take
the following values: float, double, std::complex<float> and
std::complex<double>.

See:   Helmholtz equation in 3D

C++ includes: helmholtz_3d_single_layer_potential_operator.hpp ";

%feature("docstring")
Bempp::Helmholtz3dSingleLayerPotentialOperator::Helmholtz3dSingleLayerPotentialOperator
"

Constructor.

Parameters:
-----------

waveNumber:  Wave number. See Helmholtz equation in 3D for its
definition. ";

%feature("docstring")
Bempp::Helmholtz3dSingleLayerPotentialOperator::~Helmholtz3dSingleLayerPotentialOperator
"

Destructor. ";


// File: structBempp_1_1Helmholtz3dSingleLayerPotentialOperatorImpl.xml
%feature("docstring")
Bempp::Helmholtz3dSingleLayerPotentialOperatorImpl "";

%feature("docstring")
Bempp::Helmholtz3dSingleLayerPotentialOperatorImpl::Helmholtz3dSingleLayerPotentialOperatorImpl
"";


// File: classBempp_1_1IdentityOperator.xml
%feature("docstring") Bempp::IdentityOperator "

Identity operator.

Let $X$ and $Y$ be two function spaces defined on the same grid. If $X
\\\\supset Y$, an instance of IdentityOperator with domain $X$ and
range $Y$ represents the orthogonal projection operator from $X$ to
$Y$. If $X \\\\subset Y$, it represents the inclusion operator from
$X$ to $Y$. In the special case of $X = Y$, we have the standard
identity operator. In BEM++ we (ab)use the term \"identity operator\"
to refer to all these three cases.

See AbstractBoundaryOperator for the documentation of the template
parameters.

Use identityOperator() to create a BoundaryOperator object wrapping an
identity operator.

C++ includes: identity_operator.hpp ";

%feature("docstring")  Bempp::IdentityOperator::IdentityOperator "

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry. If
set to AUTO_SYMMETRY (default), the symmetry is determined
automatically by checking whether its domain and space dual to its
range are equal. If so, the operator is marked as Hermitian, and if
the basis functions are real-valued, also as symmetric.

All the three spaces must be defined on the same grid. ";

%feature("docstring")  Bempp::IdentityOperator::IdentityOperator "";

%feature("docstring")  Bempp::IdentityOperator::~IdentityOperator "";

%feature("docstring")  Bempp::IdentityOperator::id "

Return the identifier of this operator.

Identity operators are treated as equivalent if they have the same
domain, range and dual to range. ";

%feature("docstring")  Bempp::IdentityOperator::isLocal "

Return true. ";


// File: structBempp_1_1IdentityOperator_1_1Impl.xml
%feature("docstring") Bempp::IdentityOperator::Impl "";

%feature("docstring")  Bempp::IdentityOperator::Impl::Impl "";


// File: classBempp_1_1IdentityOperatorId.xml
%feature("docstring") Bempp::IdentityOperatorId "";

%feature("docstring")  Bempp::IdentityOperatorId::IdentityOperatorId "";

%feature("docstring")  Bempp::IdentityOperatorId::hash "";

%feature("docstring")  Bempp::IdentityOperatorId::isEqual "";


// File: classBempp_1_1IdSet.xml
%feature("docstring") Bempp::IdSet "

Abstract wrapper of an id set.

C++ includes: id_set.hpp ";

%feature("docstring")  Bempp::IdSet::~IdSet "

Destructor. ";

%feature("docstring")  Bempp::IdSet::entityId "

Id of the entity e of codimension 0. ";

%feature("docstring")  Bempp::IdSet::entityId "

Id of the entity e of codimension 1. ";

%feature("docstring")  Bempp::IdSet::entityId "

Id of the entity e of codimension 2. ";

%feature("docstring")  Bempp::IdSet::entityId "

Id of the entity e of codimension 3. ";

%feature("docstring")  Bempp::IdSet::subEntityId "

Id of i'th subentity of codimension codimSub of entity e of
codimension 0. ";


// File: classBempp_1_1IndexPermutation.xml
%feature("docstring") Bempp::IndexPermutation "

Permutation of indices.

This class is used in ACA-mode assembly.

C++ includes: index_permutation.hpp ";

%feature("docstring")  Bempp::IndexPermutation::IndexPermutation "";

%feature("docstring")  Bempp::IndexPermutation::permuteVector "

Convert a vector from original to permuted ordering. ";

%feature("docstring")  Bempp::IndexPermutation::unpermuteVector "

Convert a vector from permuted to original ordering. ";

%feature("docstring")  Bempp::IndexPermutation::permuted "

Permute index. ";


// File: classBempp_1_1IndexSet.xml
%feature("docstring") Bempp::IndexSet "

Abstract wrapper of an index set.

C++ includes: index_set.hpp ";

%feature("docstring")  Bempp::IndexSet::~IndexSet "

Destructor. ";

%feature("docstring")  Bempp::IndexSet::entityIndex "

Index of the entity of codimension 0.

The result of calling this method with an entity that is not in the
index set is undefined.

An index in the range 0 ... (max number of entities in set - 1). ";

%feature("docstring")  Bempp::IndexSet::entityIndex "

Index of the entity of codimension 1.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::IndexSet::entityIndex "

Index of the entity of codimension 2.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::IndexSet::entityIndex "

Index of the entity of codimension 3.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::IndexSet::subEntityIndex "

Index of i'th subentity of codimension codimSub of entity e of
codimension 0. ";


// File: classBempp_1_1InterpolatedFunction.xml
%feature("docstring") Bempp::InterpolatedFunction "

Function defined by its values at a set of interpolation points and an
interpolation method.

C++ includes: interpolated_function.hpp ";

%feature("docstring")
Bempp::InterpolatedFunction::InterpolatedFunction "

Construct function given its values at vertices of a grid. ";

%feature("docstring")  Bempp::InterpolatedFunction::grid "

Interpolation grid. ";

%feature("docstring")  Bempp::InterpolatedFunction::worldDimension "";

%feature("docstring")  Bempp::InterpolatedFunction::codomainDimension
"";

%feature("docstring")
Bempp::InterpolatedFunction::addGeometricalDependencies "";

%feature("docstring")  Bempp::InterpolatedFunction::evaluate "";

%feature("docstring")  Bempp::InterpolatedFunction::exportToVtk "

Export the function to a VTK file.

Parameters:
-----------

dataLabel:  Label used to identify the function in the VTK file.

fileNamesBase:  Base name of the output files. It should not contain
any directory part or filename extensions.

filesPath:  Output directory. Can be set to NULL, in which case the
files are output in the current directory.

type:  Output type (default: ASCII). See Dune reference manual for
more details. ";


// File: classBempp_1_1Laplace3dAdjointDoubleLayerBoundaryOperator.xml
%feature("docstring")
Bempp::Laplace3dAdjointDoubleLayerBoundaryOperator "

Adjoint double-layer-potential boundary operator for the Laplace
equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  ResultType_
Type used to represent elements of the weak form of the operator.

Both template parameters can take the following values: float, double,
std::complex<float> and std::complex<double>. Both types must have the
same precision: for instance, mixing float with std::complex<double>
is not allowed. The parameter ResultType_ is by default set to
BasisFunctionType_. You should override that only if you set
BasisFunctionType_ to a real type, but you want the entries of the
operator's weak form to be stored as complex numbers.

See:   Laplace equation in 3D

C++ includes: laplace_3d_adjoint_double_layer_boundary_operator.hpp ";

%feature("docstring")
Bempp::Laplace3dAdjointDoubleLayerBoundaryOperator::Laplace3dAdjointDoubleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1Laplace3dAdjointDoubleLayerBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::Laplace3dAdjointDoubleLayerBoundaryOperatorImpl "";

%feature("docstring")
Bempp::Laplace3dAdjointDoubleLayerBoundaryOperatorImpl::Laplace3dAdjointDoubleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1Laplace3dBoundaryOperatorBase.xml
%feature("docstring") Bempp::Laplace3dBoundaryOperatorBase "

Base class for boundary operators for the Laplace equation in 3D.

Impl Type of the internal implementation object.  BasisFunctionType_
Type of the values of the basis functions into which functions acted
upon by the operator are expanded.  ResultType_ Type used to represent
elements of the weak form form of the operator.

The latter two template parameters can take the following values:
float, double, std::complex<float> and std::complex<double>. Both
types must have the same precision: for instance, mixing float with
std::complex<double> is not allowed. The parameter ResultType_ is by
default set to BasisFunctionType_. You should override that only if
you set BasisFunctionType_ to a real type, but you want the entries of
the operator's weak form to be stored as complex numbers.

See:   Laplace equation in 3D

C++ includes: laplace_3d_boundary_operator_base.hpp ";

%feature("docstring")
Bempp::Laplace3dBoundaryOperatorBase::Laplace3dBoundaryOperatorBase "

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";

%feature("docstring")
Bempp::Laplace3dBoundaryOperatorBase::Laplace3dBoundaryOperatorBase "

Copy constructor. ";

%feature("docstring")
Bempp::Laplace3dBoundaryOperatorBase::~Laplace3dBoundaryOperatorBase "";

%feature("docstring")  Bempp::Laplace3dBoundaryOperatorBase::id "

Return the identifier of this operator.

Two boundary operators related to the Laplace equation are treated as
identical, and hence having the same weak form, if they have the same
C++ type (e.g. Laplace3dDoubleLayerBoundaryOperator<double, double>),
domain space, range space and space dual to range. ";


// File: classBempp_1_1Laplace3dBoundaryOperatorId.xml
%feature("docstring") Bempp::Laplace3dBoundaryOperatorId "";

%feature("docstring")
Bempp::Laplace3dBoundaryOperatorId::Laplace3dBoundaryOperatorId "";

%feature("docstring")  Bempp::Laplace3dBoundaryOperatorId::hash "";

%feature("docstring")  Bempp::Laplace3dBoundaryOperatorId::dump "";

%feature("docstring")  Bempp::Laplace3dBoundaryOperatorId::isEqual "";


// File: classBempp_1_1Laplace3dDoubleLayerBoundaryOperator.xml
%feature("docstring") Bempp::Laplace3dDoubleLayerBoundaryOperator "

Double-layer-potential boundary operator for the Laplace equation in
3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  ResultType_
Type used to represent elements of the weak form form of the operator.

Both template parameters can take the following values: float, double,
std::complex<float> and std::complex<double>. Both types must have the
same precision: for instance, mixing float with std::complex<double>
is not allowed. The parameter ResultType_ is by default set to
BasisFunctionType_. You should override that only if you set
BasisFunctionType_ to a real type, but you want the entries of the
operator's weak form to be stored as complex numbers.

See:   Laplace equation in 3D

C++ includes: laplace_3d_double_layer_boundary_operator.hpp ";

%feature("docstring")
Bempp::Laplace3dDoubleLayerBoundaryOperator::Laplace3dDoubleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1Laplace3dDoubleLayerBoundaryOperatorImpl.xml
%feature("docstring") Bempp::Laplace3dDoubleLayerBoundaryOperatorImpl
"";

%feature("docstring")
Bempp::Laplace3dDoubleLayerBoundaryOperatorImpl::Laplace3dDoubleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1Laplace3dDoubleLayerPotentialOperator.xml
%feature("docstring") Bempp::Laplace3dDoubleLayerPotentialOperator "

Double-layer potential operator for the Laplace equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  ResultType_
Type of the values of the potential.

Both template parameters can take the following values: float, double,
std::complex<float> and std::complex<double>. Both types must have the
same precision: for instance, mixing float with std::complex<double>
is not allowed. The parameter ResultType_ is by default set to
BasisFunctionType_. You should override that only if you set
BasisFunctionType_ to a real type, but you want the values of the
potential to be stored as complex numbers.

See:   Laplace equation in 3D

C++ includes: laplace_3d_double_layer_potential_operator.hpp ";

%feature("docstring")
Bempp::Laplace3dDoubleLayerPotentialOperator::Laplace3dDoubleLayerPotentialOperator
"

Constructor. ";

%feature("docstring")
Bempp::Laplace3dDoubleLayerPotentialOperator::~Laplace3dDoubleLayerPotentialOperator
"

Destructor. ";


// File: structBempp_1_1Laplace3dDoubleLayerPotentialOperatorImpl.xml
%feature("docstring") Bempp::Laplace3dDoubleLayerPotentialOperatorImpl
"";

%feature("docstring")
Bempp::Laplace3dDoubleLayerPotentialOperatorImpl::Laplace3dDoubleLayerPotentialOperatorImpl
"";


// File: classBempp_1_1Laplace3dHypersingularBoundaryOperator.xml
%feature("docstring") Bempp::Laplace3dHypersingularBoundaryOperator "

Hypersingular boundary operator for the Laplace equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  ResultType_
Type used to represent elements of the weak form of the operator.

Both template parameters can take the following values: float, double,
std::complex<float> and std::complex<double>. Both types must have the
same precision: for instance, mixing float with std::complex<double>
is not allowed. The parameter ResultType_ is by default set to
BasisFunctionType_. You should override that only if you set
BasisFunctionType_ to a real type, but you want the entries of the
operator's weak form to be stored as complex numbers.

See:   Laplace equation in 3D

C++ includes: laplace_3d_hypersingular_boundary_operator.hpp ";

%feature("docstring")
Bempp::Laplace3dHypersingularBoundaryOperator::Laplace3dHypersingularBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1Laplace3dHypersingularBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::Laplace3dHypersingularBoundaryOperatorImpl "";

%feature("docstring")
Bempp::Laplace3dHypersingularBoundaryOperatorImpl::Laplace3dHypersingularBoundaryOperatorImpl
"";


// File: classBempp_1_1Laplace3dPotentialOperatorBase.xml
%feature("docstring") Bempp::Laplace3dPotentialOperatorBase "

Base class for potential operators related to the Laplace equation in
3D.

Impl Type of the internal implementation object.  BasisFunctionType_
Type of the values of the basis functions into which functions acted
upon by the operator are expanded.  ResultType_ Type of the values of
the potential.

The latter two template parameters can take the following values:
float, double, std::complex<float> and std::complex<double>. Both
types must have the same precision: for instance, mixing float with
std::complex<double> is not allowed. The parameter ResultType_ is by
default set to BasisFunctionType_. You should override that only if
you set BasisFunctionType_ to a real type, but you want the potential
values to be stored as complex numbers.

See:   Laplace equation in 3D

C++ includes: laplace_3d_potential_operator_base.hpp ";

%feature("docstring")
Bempp::Laplace3dPotentialOperatorBase::Laplace3dPotentialOperatorBase
"

Constructor. ";

%feature("docstring")
Bempp::Laplace3dPotentialOperatorBase::Laplace3dPotentialOperatorBase
"

Copy constructor. ";

%feature("docstring")
Bempp::Laplace3dPotentialOperatorBase::~Laplace3dPotentialOperatorBase
"

Destructor. ";


// File: classBempp_1_1Laplace3dSingleLayerBoundaryOperator.xml
%feature("docstring") Bempp::Laplace3dSingleLayerBoundaryOperator "

Single-layer-potential boundary operator for the Laplace equation in
3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  ResultType_
Type used to represent elements of the weak form of the operator.

Both template parameters can take the following values: float, double,
std::complex<float> and std::complex<double>. Both types must have the
same precision: for instance, mixing float with std::complex<double>
is not allowed. The parameter ResultType_ is by default set to
BasisFunctionType_. You should override that only if you set
BasisFunctionType_ to a real type, but you want the entries of the
operator's weak form to be stored as complex numbers.

See:   Laplace equation in 3D

C++ includes: laplace_3d_single_layer_boundary_operator.hpp ";

%feature("docstring")
Bempp::Laplace3dSingleLayerBoundaryOperator::Laplace3dSingleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1Laplace3dSingleLayerBoundaryOperatorImpl.xml
%feature("docstring") Bempp::Laplace3dSingleLayerBoundaryOperatorImpl
"";

%feature("docstring")
Bempp::Laplace3dSingleLayerBoundaryOperatorImpl::Laplace3dSingleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1Laplace3dSingleLayerPotentialOperator.xml
%feature("docstring") Bempp::Laplace3dSingleLayerPotentialOperator "

Single-layer potential operator for the Laplace equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  ResultType_
Type of the values of the potential.

Both template parameters can take the following values: float, double,
std::complex<float> and std::complex<double>. Both types must have the
same precision: for instance, mixing float with std::complex<double>
is not allowed. The parameter ResultType_ is by default set to
BasisFunctionType_. You should override that only if you set
BasisFunctionType_ to a real type, but you want the values of the
potential to be stored as complex numbers.

See:   Laplace equation in 3D

C++ includes: laplace_3d_single_layer_potential_operator.hpp ";

%feature("docstring")
Bempp::Laplace3dSingleLayerPotentialOperator::Laplace3dSingleLayerPotentialOperator
"

Constructor. ";

%feature("docstring")
Bempp::Laplace3dSingleLayerPotentialOperator::~Laplace3dSingleLayerPotentialOperator
"

Destructor. ";


// File: structBempp_1_1Laplace3dSingleLayerPotentialOperatorImpl.xml
%feature("docstring") Bempp::Laplace3dSingleLayerPotentialOperatorImpl
"";

%feature("docstring")
Bempp::Laplace3dSingleLayerPotentialOperatorImpl::Laplace3dSingleLayerPotentialOperatorImpl
"";


// File: classBempp_1_1Lazy.xml
%feature("docstring") Bempp::Lazy "

Thread-safe wrapper of a lazily inititialised object.

T Type of the stored object.  Initializer Type of a copy-constructible
functor providing the member function std::unique_ptr<T> operator()()
that will be used to construct the object the first time it is
requested.  Mutex Type of the mutex to be used to lock the object
during initialisation.

C++ includes: lazy.hpp ";

%feature("docstring")  Bempp::Lazy::Lazy "";

%feature("docstring")  Bempp::Lazy::~Lazy "";

%feature("docstring")  Bempp::Lazy::get "";


// File: structBempp_1_1LocalAssemblerConstructionHelper.xml
%feature("docstring") Bempp::LocalAssemblerConstructionHelper "

Utility functions used during weak-form assembly.

C++ includes: local_assembler_construction_helper.hpp ";


// File: structBempp_1_1LocalDof.xml
%feature("docstring") Bempp::LocalDof "";

%feature("docstring")  Bempp::LocalDof::LocalDof "";

%feature("docstring")  Bempp::LocalDof::LocalDof "";


// File: classBempp_1_1Mapper.xml
%feature("docstring") Bempp::Mapper "

Abstract mapper class.

A mapper provides a mapping from a set of entities to a range of
integers from 0 to ( size() - 1), where size() is the number of
entities contained in the set.

C++ includes: mapper.hpp ";

%feature("docstring")  Bempp::Mapper::~Mapper "";

%feature("docstring")  Bempp::Mapper::size "

Total number of entities in the entity set managed by the mapper. ";

%feature("docstring")  Bempp::Mapper::entityIndex "

Index of the entity of codimension 0.

The result of calling this method with an entity that does not belong
to the mapped set is undefined.

An index in the range 0 ... ( size() - 1). ";

%feature("docstring")  Bempp::Mapper::entityIndex "

Index of the entity of codimension 1.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::Mapper::entityIndex "

Index of the entity of codimension 2.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::Mapper::entityIndex "

Index of the entity of codimension 3.

This is an overloaded member function, provided for convenience. It
differs from the above function only in what argument(s) it accepts.
";

%feature("docstring")  Bempp::Mapper::subEntityIndex "

Index of i'th subentity of codimension codimSub of entity e of
codimension 0. ";


// File: classBempp_1_1ModifiedHelmholtz3dAdjointDoubleLayerBoundaryOperator.xml
%feature("docstring")
Bempp::ModifiedHelmholtz3dAdjointDoubleLayerBoundaryOperator "

Adjoint double-layer-potential boundary operator for the modified
Helmholtz equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  KernelType_
Type of the values of the kernel functions occurring in the integrand
of the operator.  ResultType_ Type used to represent elements of the
weak form form of the operator.

The latter three template parameters can take the following values:
float, double, std::complex<float> and std::complex<double>. All types
must have the same precision: for instance, mixing float with
std::complex<double> is not allowed. The parameter ResultType_ is by
default set to \"larger\" of BasisFunctionType_ and KernelType_, e.g.
for BasisFunctionType_ = double and KernelType_ = std::complex<double>
it is set to std::complex<double>. You should override that only if
you set both BasisFunctionType_ and KernelType_ to a real type, but
you want the entries of the operator's weak form to be stored as
complex numbers.

Note that setting KernelType_ to a real type implies that the wave
number must also be chosen purely real.

See:   Modified Helmholtz equation in 3D

C++ includes:
modified_helmholtz_3d_adjoint_double_layer_boundary_operator.hpp ";

%feature("docstring")
Bempp::ModifiedHelmholtz3dAdjointDoubleLayerBoundaryOperator::ModifiedHelmholtz3dAdjointDoubleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Modified Helmholtz equation in 3D for
its definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1ModifiedHelmholtz3dAdjointDoubleLayerBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::ModifiedHelmholtz3dAdjointDoubleLayerBoundaryOperatorImpl "";

%feature("docstring")
Bempp::ModifiedHelmholtz3dAdjointDoubleLayerBoundaryOperatorImpl::ModifiedHelmholtz3dAdjointDoubleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1ModifiedHelmholtz3dBoundaryOperatorBase.xml
%feature("docstring") Bempp::ModifiedHelmholtz3dBoundaryOperatorBase "

Base class for boundary operators for the modified Helmholtz equation
in 3D.

Impl Type of the internal implementation object.  BasisFunctionType_
Type of the values of the basis functions into which functions acted
upon by the operator are expanded.  KernelType_ Type of the values of
the kernel functions occurring in the integrand of the operator.
ResultType_ Type used to represent elements of the weak form form of
the operator.

The latter three template parameters can take the following values:
float, double, std::complex<float> and std::complex<double>. All types
must have the same precision: for instance, mixing float with
std::complex<double> is not allowed. The parameter ResultType_ is by
default set to \"larger\" of BasisFunctionType_ and KernelType_, e.g.
for BasisFunctionType_ = double and KernelType_ = std::complex<double>
it is set to std::complex<double>. You should override that only if
you set both BasisFunctionType_ and KernelType_ to a real type, but
you want the entries of the operator's weak form to be stored as
complex numbers.

Note that setting KernelType_ to a real type implies that the wave
number must also be chosen purely real.

See:   Modified Helmholtz equation in 3D

C++ includes: modified_helmholtz_3d_boundary_operator_base.hpp ";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorBase::ModifiedHelmholtz3dBoundaryOperatorBase
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Modified Helmholtz equation in 3D for
its definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorBase::ModifiedHelmholtz3dBoundaryOperatorBase
"

Copy constructor. ";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorBase::~ModifiedHelmholtz3dBoundaryOperatorBase
"";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorBase::waveNumber "

Return the wave number set previously in the constructor. ";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorBase::id "

Return the identifier of this operator.

Two boundary operators related to the modified Helmholtz equation are
treated as identical, and hence having the same weak form, if they
have the same C++ type (e.g.
Helmholtz3dDoubleLayerBoundaryOperator<double, double, double>),
domain space, range space, space dual to range and wave number. ";


// File: classBempp_1_1ModifiedHelmholtz3dBoundaryOperatorId.xml
%feature("docstring") Bempp::ModifiedHelmholtz3dBoundaryOperatorId "";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorId::ModifiedHelmholtz3dBoundaryOperatorId
"";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorId::hash "";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorId::dump "";

%feature("docstring")
Bempp::ModifiedHelmholtz3dBoundaryOperatorId::isEqual "";


// File: classBempp_1_1ModifiedHelmholtz3dDoubleLayerBoundaryOperator.xml
%feature("docstring")
Bempp::ModifiedHelmholtz3dDoubleLayerBoundaryOperator "

Double-layer-potential boundary operator for the modified Helmholtz
equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  KernelType_
Type of the values of the kernel functions occurring in the integrand
of the operator.  ResultType_ Type used to represent elements of the
weak form form of the operator.

The latter three template parameters can take the following values:
float, double, std::complex<float> and std::complex<double>. All types
must have the same precision: for instance, mixing float with
std::complex<double> is not allowed. The parameter ResultType_ is by
default set to \"larger\" of BasisFunctionType_ and KernelType_, e.g.
for BasisFunctionType_ = double and KernelType_ = std::complex<double>
it is set to std::complex<double>. You should override that only if
you set both BasisFunctionType_ and KernelType_ to a real type, but
you want the entries of the operator's weak form to be stored as
complex numbers.

Note that setting KernelType_ to a real type implies that the wave
number must also be chosen purely real.

See:   Modified Helmholtz equation in 3D

C++ includes: modified_helmholtz_3d_double_layer_boundary_operator.hpp
";

%feature("docstring")
Bempp::ModifiedHelmholtz3dDoubleLayerBoundaryOperator::ModifiedHelmholtz3dDoubleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Modified Helmholtz equation in 3D for
its definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1ModifiedHelmholtz3dDoubleLayerBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::ModifiedHelmholtz3dDoubleLayerBoundaryOperatorImpl "";

%feature("docstring")
Bempp::ModifiedHelmholtz3dDoubleLayerBoundaryOperatorImpl::ModifiedHelmholtz3dDoubleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1ModifiedHelmholtz3dHypersingularBoundaryOperator.xml
%feature("docstring")
Bempp::ModifiedHelmholtz3dHypersingularBoundaryOperator "

Hypersingular boundary operator for the modified Helmholtz equation in
3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  KernelType_
Type of the values of the kernel functions occurring in the integrand
of the operator.  ResultType_ Type used to represent elements of the
weak form form of the operator.

The latter three template parameters can take the following values:
float, double, std::complex<float> and std::complex<double>. All types
must have the same precision: for instance, mixing float with
std::complex<double> is not allowed. The parameter ResultType_ is by
default set to \"larger\" of BasisFunctionType_ and KernelType_, e.g.
for BasisFunctionType_ = double and KernelType_ = std::complex<double>
it is set to std::complex<double>. You should override that only if
you set both BasisFunctionType_ and KernelType_ to a real type, but
you want the entries of the operator's weak form to be stored as
complex numbers.

Note that setting KernelType_ to a real type implies that the wave
number must also be chosen purely real.

See:   Modified Helmholtz equation in 3D

C++ includes:
modified_helmholtz_3d_hypersingular_boundary_operator.hpp ";

%feature("docstring")
Bempp::ModifiedHelmholtz3dHypersingularBoundaryOperator::ModifiedHelmholtz3dHypersingularBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Modified Helmholtz equation in 3D for
its definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1ModifiedHelmholtz3dHypersingularBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::ModifiedHelmholtz3dHypersingularBoundaryOperatorImpl "";

%feature("docstring")
Bempp::ModifiedHelmholtz3dHypersingularBoundaryOperatorImpl::ModifiedHelmholtz3dHypersingularBoundaryOperatorImpl
"";


// File: classBempp_1_1ModifiedHelmholtz3dSingleLayerBoundaryOperator.xml
%feature("docstring")
Bempp::ModifiedHelmholtz3dSingleLayerBoundaryOperator "

Single-layer-potential boundary operator for the modified Helmholtz
equation in 3D.

BasisFunctionType_ Type of the values of the basis functions into
which functions acted upon by the operator are expanded.  KernelType_
Type of the values of the kernel functions occurring in the integrand
of the operator.  ResultType_ Type used to represent elements of the
weak form form of the operator.

The latter three template parameters can take the following values:
float, double, std::complex<float> and std::complex<double>. All types
must have the same precision: for instance, mixing float with
std::complex<double> is not allowed. The parameter ResultType_ is by
default set to \"larger\" of BasisFunctionType_ and KernelType_, e.g.
for BasisFunctionType_ = double and KernelType_ = std::complex<double>
it is set to std::complex<double>. You should override that only if
you set both BasisFunctionType_ and KernelType_ to a real type, but
you want the entries of the operator's weak form to be stored as
complex numbers.

Note that setting KernelType_ to a real type implies that the wave
number must also be chosen purely real.

See:   Modified Helmholtz equation in 3D

C++ includes: modified_helmholtz_3d_single_layer_boundary_operator.hpp
";

%feature("docstring")
Bempp::ModifiedHelmholtz3dSingleLayerBoundaryOperator::ModifiedHelmholtz3dSingleLayerBoundaryOperator
"

Constructor.

Parameters:
-----------

domain:  Function space being the domain of the operator.

range:  Function space being the range of the operator.

dualToRange:  Function space dual to the the range of the operator.

waveNumber:  Wave number. See Modified Helmholtz equation in 3D for
its definition.

label:  Textual label of the operator. If empty, a unique label is
generated automatically.

symmetry:  Symmetry of the weak form of the operator. Can be any
combination of the flags defined in the enumeration type Symmetry.

None of the shared pointers may be null and the spaces range and
dualToRange must be defined on the same grid, otherwise an exception
is thrown. ";


// File: structBempp_1_1ModifiedHelmholtz3dSingleLayerBoundaryOperatorImpl.xml
%feature("docstring")
Bempp::ModifiedHelmholtz3dSingleLayerBoundaryOperatorImpl "";

%feature("docstring")
Bempp::ModifiedHelmholtz3dSingleLayerBoundaryOperatorImpl::ModifiedHelmholtz3dSingleLayerBoundaryOperatorImpl
"";


// File: classBempp_1_1NotImplementedError.xml
%feature("docstring") Bempp::NotImplementedError "";

%feature("docstring")  Bempp::NotImplementedError::NotImplementedError
"";

%feature("docstring")
Bempp::NotImplementedError::~NotImplementedError "throw ()";

%feature("docstring")  Bempp::NotImplementedError::what "throw ()";


// File: classBempp_1_1NumericalQuadratureStrategy.xml
%feature("docstring") Bempp::NumericalQuadratureStrategy "

Numerical quadrature strategy.

A quadrature strategy provides functions constructing local assemblers
used to discretize boundary operators and user-defined functions. A
particular quadrature strategy determines how the integrals involved
in this discretization are evaluated.

The local assemblers constructed by this class use numerical
quadrature to evaluate the necessary integrals. Singular integrals are
transformed into regular ones as described in S. Sauter, Ch. Schwab,
\"Boundary Element Methods\" (2010). Quadrature accuracy can be
influenced by parameters given during the construction.

C++ includes: numerical_quadrature_strategy.hpp ";

%feature("docstring")
Bempp::NumericalQuadratureStrategy::NumericalQuadratureStrategy "

Construct a numerical quadrature strategy with default accuracy
settings.

Calling this constructor is equivalent to calling the other
constructor with accuracyOptions equal to AccuracyOptions(). ";

%feature("docstring")
Bempp::NumericalQuadratureStrategy::NumericalQuadratureStrategy "

Construct a numerical quadrature strategy with prescribed accuracy
settings.

The quadrature order for different types of integrals is determined in
the following way:

The field accuracyOptions.doubleRegular controls the evaluation of
double integrals of the form \\\\[ \\\\int_{\\\\Gamma}
\\\\int_{\\\\Sigma} f(x, y) \\\\, d\\\\Gamma(x) \\\\, d\\\\Sigma(y),
\\\\] where $\\\\Gamma$ and $\\\\Sigma$ are two disjoint elements and
$f(x, y)$ is a function regular for $x \\\\in \\\\Gamma$ and $y \\\\in
\\\\Sigma$. An integral of the above form is approximated by \\\\[
\\\\sum_{i=1}^m \\\\sum_{j=1}^n w_i^m w_j^n \\\\, f(x_i^m, y_j^n),
\\\\] where $x_i^m$ and $y_j^n$ are appropriate quadrature points and
$w_i^m$ and $w_j^n$ are the corresponding quadrature weights. By
default, these are chosen so that the order of accuracy of the
quadrature of each element is equal to the maximum degree of the
polynomials belonging to the basis attached to that element. In other
words, the quadrature rule is chosen so that a function $f(x, y)$
being a product of two polynomials, $u(x)$ and $v(y)$, with degrees
equal to the orders of the bases attached to elements $\\\\Gamma$ and
$\\\\Sigma$ would be integrated exactly. For instance, for a pair of
elements endowed with linear bases, single-point quadrature is by
default used on both elements.

This default integration order may be insufficient. It can be
increased e.g. by calling where n is the desired increase of the order
of accuracy of the quadrature on each element above the default value.
Alternatively, can be called to use a quadrature rule with order of
accuracy n on each element.

The field accuracyOptions.doubleSingular controls the evaluation of
double integrals of the same form as above, but on pairs of elements
$\\\\Gamma$ and $\\\\Sigma$ sharing at least a single point and with
the function $f(x, y)$ having a singularity at $x = y$. Such integrals
are evaluated by first applying an appropriate coordinate
transformation to remove the singularity of the integrand, as
described in the book of Sauter and Schwab cited before, and then
approximating the new integral with a tensor-product Gaussian
quadrature rule with order of accuracy in each dimension choosen by
default as $\\\\max(p, q) + 5$, where $p$ and $q$ are the orders of
the bases attached to elements $\\\\Gamma$ and $\\\\Sigma$.

The field accuracyOptions.singleRegular controls the evaluation of
integrals over single elements \\\\[ \\\\int_{\\\\Gamma} f(x) \\\\,
d\\\\Gamma(x) \\\\] of regular functions $f(x)$. They are evaluated
using a Gaussian quadrature rule with order of accuracy taken by
default as twice the order of the basis attached to the element
$\\\\Gamma$. ";


// File: classBempp_1_1PiecewiseConstantScalarSpace.xml
%feature("docstring") Bempp::PiecewiseConstantScalarSpace "

Space of piecewise constant scalar functions.

C++ includes: piecewise_constant_scalar_space.hpp ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::PiecewiseConstantScalarSpace "";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::domainDimension "

Dimension of the grid on which functions from this space are defined.
";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::codomainDimension "

Dimension of the codomain of the functions.

In other words, number of components of the values of the functions.
(E.g. H1 space -> 1, H(curl) space on a 2D surface -> 2). ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::elementVariant "

Return the variant of element element.

Possible return values: 2: one-dimensional segment,

3: triangular element,

4: quadrilateral element. ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::setElementVariant "

Set the variant of element element to variant.

The element variant determines the set of basis functions defined on
the element (e.g. maximum polynomial order). Different subclasses of
Space interpret the variant argument in different ways; for more
information, see the documentation of these subclasses.

Calling this function only makes sense for subclasses implementing
adaptive function spaces. Currently there are no such subclasses. ";

%feature("docstring")  Bempp::PiecewiseConstantScalarSpace::basis "

Reference to the basis attached to the specified element. ";

%feature("docstring")  Bempp::PiecewiseConstantScalarSpace::assignDofs
"

Assign global degrees of freedom to local degrees of freedom. ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::dofsAssigned "

True if assignDofs() has been called before, false otherwise. ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::globalDofCount "

Number of global degrees of freedom.

This function returns zero if assignDofs() has not been called before.
";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::flatLocalDofCount "

Total number of local degrees of freedom on all elements. ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::getGlobalDofs "

Map local degrees of freedom residing on an element to global degrees
of freedom.

Parameters:
-----------

element:  An element of the grid grid().

dofs:  Indices of the global degrees of freedom corresponding to the
local degrees of freedom residing on element.

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::global2localDofs "

Map global degrees of freedom to local degrees of freedom.

Parameters:
-----------

globalDofs:   Vector containing indices of global degrees of freedom.

localDofs:   Vector whose ith element is the vector containing all the
local degrees of freedom that are mapped to the global degree of
freedom globalDofs[i].

Note that a local degree of freedom (LocalDof) is a combination of an
EntityIndex and LocalDofIndex, as explained in its documentation.

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::flatLocal2localDofs "

Map flat indices of local degrees of freedom to local degrees of
freedom.

Parameters:
-----------

flatLocalDofs:   Vector containing flat indices of local degrees of
freedom.

localDofs:   Vector whose ith element is the local degree of freedom
with flat index given by flatLocalDofs[i].

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::getGlobalDofPositions "";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::getFlatLocalDofPositions "";

%feature("docstring")
Bempp::PiecewiseConstantScalarSpace::dumpClusterIds "

Write a VTK file showing the distribution of global degrees of freedom
into clusters.

Parameters:
-----------

fileName:  Name of the VTK file to be created (without extension).

clusterIdsOfGlobalDofs:   Vector whose ith element contains the
identifier of the cluster to which ith global degree has been
assigned.

This function generates a VTK file containing a single data series
mapping the ``positions'' (see globalDofPositions()) of global degrees
of freedom to the identifiers of the clusters to which these degrees
of freedom have been assigned. It is intended for debugging clustering
algorithms.

An exception is thrown if this function is called prior to calling
assignDofs(). ";


// File: classBempp_1_1PiecewiseLinearContinuousScalarSpace.xml
%feature("docstring") Bempp::PiecewiseLinearContinuousScalarSpace "

Space of continuous, piecewise linear scalar functions.

C++ includes: piecewise_linear_continuous_scalar_space.hpp ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::PiecewiseLinearContinuousScalarSpace
"";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::~PiecewiseLinearContinuousScalarSpace
"";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::domainDimension "

Dimension of the grid on which functions from this space are defined.
";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::codomainDimension "

Dimension of the codomain of the functions.

In other words, number of components of the values of the functions.
(E.g. H1 space -> 1, H(curl) space on a 2D surface -> 2). ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::elementVariant "

Return the variant of element element.

Possible return values: 2: one-dimensional segment,

3: triangular element,

4: quadrilateral element. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::setElementVariant "

Set the variant of element element to variant.

The element variant determines the set of basis functions defined on
the element (e.g. maximum polynomial order). Different subclasses of
Space interpret the variant argument in different ways; for more
information, see the documentation of these subclasses.

Calling this function only makes sense for subclasses implementing
adaptive function spaces. Currently there are no such subclasses. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::basis "

Reference to the basis attached to the specified element. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::assignDofs "

Assign global degrees of freedom to local degrees of freedom. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::dofsAssigned "

True if assignDofs() has been called before, false otherwise. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::globalDofCount "

Number of global degrees of freedom.

This function returns zero if assignDofs() has not been called before.
";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::flatLocalDofCount "

Total number of local degrees of freedom on all elements. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::getGlobalDofs "

Map local degrees of freedom residing on an element to global degrees
of freedom.

Parameters:
-----------

element:  An element of the grid grid().

dofs:  Indices of the global degrees of freedom corresponding to the
local degrees of freedom residing on element.

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::global2localDofs "

Map global degrees of freedom to local degrees of freedom.

Parameters:
-----------

globalDofs:   Vector containing indices of global degrees of freedom.

localDofs:   Vector whose ith element is the vector containing all the
local degrees of freedom that are mapped to the global degree of
freedom globalDofs[i].

Note that a local degree of freedom (LocalDof) is a combination of an
EntityIndex and LocalDofIndex, as explained in its documentation.

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::flatLocal2localDofs "

Map flat indices of local degrees of freedom to local degrees of
freedom.

Parameters:
-----------

flatLocalDofs:   Vector containing flat indices of local degrees of
freedom.

localDofs:   Vector whose ith element is the local degree of freedom
with flat index given by flatLocalDofs[i].

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::getGlobalDofPositions "";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::getFlatLocalDofPositions
"";

%feature("docstring")
Bempp::PiecewiseLinearContinuousScalarSpace::dumpClusterIds "

Write a VTK file showing the distribution of global degrees of freedom
into clusters.

Parameters:
-----------

fileName:  Name of the VTK file to be created (without extension).

clusterIdsOfGlobalDofs:   Vector whose ith element contains the
identifier of the cluster to which ith global degree has been
assigned.

This function generates a VTK file containing a single data series
mapping the ``positions'' (see globalDofPositions()) of global degrees
of freedom to the identifiers of the clusters to which these degrees
of freedom have been assigned. It is intended for debugging clustering
algorithms.

An exception is thrown if this function is called prior to calling
assignDofs(). ";


// File: structBempp_1_1Point3D.xml
%feature("docstring") Bempp::Point3D "";


// File: classBempp_1_1PotentialOperator.xml
%feature("docstring") Bempp::PotentialOperator "

Potential operator.

This class represents a linear operator that, acting on a function $g$
defined on a surface $\\\\Gamma$ embedded in a space $\\\\Omega$ of
dimension higher by one, produces a *potential* defined at any point
of $\\\\Omega$ lying outside $\\\\Gamma$. The function $g$ is called
the *charge distribution*.

The functions evaluateOnGrid() and evaluateAtPoints() can be used to
evaluate the potential produced by a given charge distribution,
represented with a GridFunction object, at specified points in
$\\\\Omega \\\\setminus \\\\Gamma$.

BasisFunctionType_ Type of the values of the (components of the) basis
functions into which functions acted upon by the operator are
expanded.  ResultType_ Type of the values of the (components of the)
potential.

Both template parameters can take the following values: float, double,
std::complex<float> and std::complex<double>. Both types must have the
same precision: for instance, mixing float with std::complex<double>
is not allowed. If BasisFunctionType_ is set to a complex type, then
ResultType_ must be set to the same type.

C++ includes: potential_operator.hpp ";

%feature("docstring")  Bempp::PotentialOperator::~PotentialOperator "

Destructor. ";

%feature("docstring")  Bempp::PotentialOperator::evaluateOnGrid "

Evaluate the potential of a given charge distribution on a prescribed
grid.

Parameters:
-----------

argument:  Argument of the potential operator ( $\\\\psi(y)$ in the
notation above), represented by a grid function.

evaluationGrid:   Grid at whose vertices the potential will be
evaluated. The grid may have arbitrary dimension, but must be embedded
in a world of the same dimension as argument.grid().

quadStrategy:  A QuadratureStrategy object controlling how the
integrals will be evaluated.

options:  Evaluation options.

The potential represented by a function interpolated on the vertices
of evaluationGrid.

This function is not designed to yield accurate values of the
potential on the surface $\\\\Gamma$ containing the charge
distribution, i.e. argument.grid(), even if the potential has a unique
extension from $\\\\Omega \\\\setminus \\\\Gamma$ to $\\\\Gamma$.
Hence values of the potential at any vertices of evaluationGrid that
coincide with $\\\\Gamma$ can be badly wrong.  The current
implementation does not yet take special measures to prevent loss of
accuracy *near* $\\\\Gamma$, either. If in doubt, increase the
quadrature accuracy. ";

%feature("docstring")  Bempp::PotentialOperator::evaluateAtPoints "

Evaluate the potential of a given charge distribution at prescribed
points.

Parameters:
-----------

argument:  Argument of the potential operator ( $\\\\psi(y)$ in the
notation above), represented by a grid function.

evaluationPoints:  2D array whose (i, j)th element is the ith
coordinate of the jth point at which the potential should be
evaluated. The first dimension of this array should be equal to
argument.grid().dimWorld().

quadStrategy:  A QuadratureStrategy object controlling how the
integrals will be evaluated.

options:  Evaluation options.

A 2D array whose (i, j)th element is the ith component of the
potential at the jth point.

This function is not designed to yield accurate values of the
potential on the surface $\\\\Gamma$ containing the charge
distribution, i.e. argument.grid(), even if the potential has a unique
extension from $\\\\Omega \\\\setminus \\\\Gamma$ to $\\\\Gamma$.
Hence values of the potential at any points belonging to $\\\\Gamma$
can be badly wrong.  The current implementation does not yet take
special measures to prevent loss of accuracy *near* $\\\\Gamma$,
either. Users are advised to increase the quadrature accuracy for
points lying in the vicinity of $\\\\Gamma$. ";


// File: classBempp_1_1Preconditioner.xml
%feature("docstring") Bempp::Preconditioner "

A simple container class to hold pointers to preconditioners.

C++ includes: preconditioner.hpp ";

%feature("docstring")  Bempp::Preconditioner::Preconditioner "";

%feature("docstring")  Bempp::Preconditioner::~Preconditioner "";

%feature("docstring")  Bempp::Preconditioner::get "";


// File: classBempp_1_1RealWrapperOfComplexThyraLinearOperator.xml
%feature("docstring") Bempp::RealWrapperOfComplexThyraLinearOperator "";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraLinearOperator::RealWrapperOfComplexThyraLinearOperator
"";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraLinearOperator::domain "";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraLinearOperator::range "";


// File: classBempp_1_1RealWrapperOfComplexThyraPreconditioner.xml
%feature("docstring") Bempp::RealWrapperOfComplexThyraPreconditioner "";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::RealWrapperOfComplexThyraPreconditioner
"";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::isLeftPrecOpConst "

Return if the underlying left preconditioner operator is const-only or
allows non-const access. ";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::getNonconstLeftPrecOp
"

Return a non-const left preconditioner linear operator if one is
designed or targeted to be applied on the left.

Preconditions: [ isLeftPrecOpConst()==true]
getLeftPrecOp().get()==NULL ";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::getLeftPrecOp "

Return a const left preconditioner linear operator if one is designed
or targeted to be applied on the left. ";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::isRightPrecOpConst "

Return if the underlying right preconditioner operator is const-only
or allows non-const access. ";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::getNonconstRightPrecOp
"

Return a non-const right preconditioner linear operator if one is
designed or targeted to be applied on the right.

Preconditions: [ isRightPrecOpConst()==true]
getRightPrecOp().get()==NULL ";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::getRightPrecOp "

Return a const right preconditioner linear operator if one is designed
or targeted to be applied on the right. ";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::isUnspecifiedPrecOpConst
"

Return if the underlying unspecified preconditioner operator is const-
only or allows non-const access. ";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::getNonconstUnspecifiedPrecOp
"

Return a non-const generic preconditioner linear operator that is not
designed or targeted to be applied on the left or on the right. ";

%feature("docstring")
Bempp::RealWrapperOfComplexThyraPreconditioner::getUnspecifiedPrecOp "

Return a const generic preconditioner linear operator that is not
designed or targeted to be applied on the left or on the right.

Preconditions: [ isUnspecifiedPrecOpConst()==true]
getUnspecifiedPrecOp().get()==NULL ";


// File: classBempp_1_1ReverseElementMapper.xml
%feature("docstring") Bempp::ReverseElementMapper "

Mapping from codim-0 entity indices to entity pointers.

C++ includes: reverse_element_mapper.hpp ";

%feature("docstring")  Bempp::ReverseElementMapper::entityPointer "

Return an entity pointer referring to the codim-0 entity having the
given index. ";


// File: classBempp_1_1ScalarSpace.xml
%feature("docstring") Bempp::ScalarSpace "

Base class for spaces of scalar-valued functions.

C++ includes: scalar_space.hpp ";

%feature("docstring")  Bempp::ScalarSpace::ScalarSpace "";

%feature("docstring")  Bempp::ScalarSpace::ScalarSpace "";

%feature("docstring")  Bempp::ScalarSpace::~ScalarSpace "";

%feature("docstring")  Bempp::ScalarSpace::shapeFunctionValue "

Transformation mapping basis functions to shape functions.

This function returns a CollectionOfBasisTransformations object
consisting of a single transformation that maps values of basis
functions defined on a reference element to those of *shape functions*
defined on a particular element of the grid.

This transformation is the identity for spaces of scalar-valued
functions, but may be more complicated for spaces of vector-valued
functions, e.g. $H(\\\\mathrm{curl})$.

Todo Perhaps change the name of this method to something more
understandable, like basisToShapeFunctionTransformation. ";


// File: structBempp_1_1ScalarSpace_1_1Impl.xml
%feature("docstring") Bempp::ScalarSpace::Impl "";

%feature("docstring")  Bempp::ScalarSpace::Impl::Impl "";


// File: classBempp_1_1ScaledAbstractBoundaryOperator.xml
%feature("docstring") Bempp::ScaledAbstractBoundaryOperator "

Scaled abstract boundary operator.

This class represents an abstract boundary operator multiplied by a
scalar.

C++ includes: scaled_abstract_boundary_operator.hpp ";

%feature("docstring")
Bempp::ScaledAbstractBoundaryOperator::ScaledAbstractBoundaryOperator
"

Constructor.

Construct the boundary operator $\\\\alpha L$, where $\\\\alpha$ is
the scalar weight and $L$ is the operator represented by boundaryOp.

By default the symmetry of the weak form of the resulting operator is
determined automatically. It can be set manually via the parameter
symmetry, which can be any combination of the flags defined in the
enumeration type Symmetry. ";

%feature("docstring")  Bempp::ScaledAbstractBoundaryOperator::isLocal
"

Return whether this operator is local.

Suppose that an operator $A$ acting on a function $f(x)$ produces
another function $g(x)$. We say that $A$ is local if the value of $g$
at any point $x$ depends only on the values of $f$ in an infinitesimal
neighbourhood of $x$.

Multiplicative and differential operators are local and discretization
of their weak forms with finite elements leads to sparse matrices.
Conversely, integral operators are in general non-local and
discretization of their weak forms leads to dense matrices. ";


// File: classBempp_1_1ScaledDiscreteBoundaryOperator.xml
%feature("docstring") Bempp::ScaledDiscreteBoundaryOperator "

Scaled discrete boundary operator.

This class represents a discrete boundary operator multiplied by a
scalar.

C++ includes: scaled_discrete_boundary_operator.hpp ";

%feature("docstring")
Bempp::ScaledDiscreteBoundaryOperator::ScaledDiscreteBoundaryOperator
"

Constructor.

Construct the discrete boundary operator $\\\\alpha L$, where
$\\\\alpha$ is the scalar multiplier and $L$ is the operator
represented by op. ";

%feature("docstring")  Bempp::ScaledDiscreteBoundaryOperator::asMatrix
"

Matrix representation of the operator.

The default implementation is slow and should be overridden where
possible. ";

%feature("docstring")  Bempp::ScaledDiscreteBoundaryOperator::rowCount
"

Number of rows of the operator. ";

%feature("docstring")
Bempp::ScaledDiscreteBoundaryOperator::columnCount "

Number of columns of the operator. ";

%feature("docstring")  Bempp::ScaledDiscreteBoundaryOperator::addBlock
"

Add a subblock of this operator to a matrix.

Perform the operation block += alpha * L[rows, cols], where block is a
matrix, alpha a scalar and L[rows, cols] a subblock of this discrete
linear operator.

Parameters:
-----------

rows:  Vector of row indices.

cols:  Vector of column indices.

alpha:  Multiplier.

block:  On entry, matrix of size ( rows.size(), cols.size()). On exit,
each element ( i, j) of this matrix will be augmented by the element (
rows[i], cols[j]) of this operator, multiplied by alpha.

Row and column indices may be unsorted.

This method need not be supported by all subclasses. It is mainly
intended for internal use during weak-form assembly. ";

%feature("docstring")
Bempp::ScaledDiscreteBoundaryOperator::asDiscreteAcaBoundaryOperator "

Return a representation that can be casted to a
DiscreteAcaBoundaryOperator.

The conversion only succeeds if all members if the DiscreteOperator
itself can be cast to a DiscreteAcaBoundaryOperator or if it is a
linear combination of DiscreteOperators that can be cast to type
DiscreteAcaBoundaryOperator. Operator compositions are not yet
supported by this function.

Parameters:
-----------

eps:  Accuracy tolerance for H-Matrix addition.

maximumRank:  maximum rank of blocks to be considered low rank in the
case of H-Matrix addition.

A pointer to a DiscreteBoundaryOperator object, which is castable to
DiscreteAcaBoundaryOperator. ";

%feature("docstring")  Bempp::ScaledDiscreteBoundaryOperator::domain "";

%feature("docstring")  Bempp::ScaledDiscreteBoundaryOperator::range "";


// File: classBempp_1_1ScatteredRange.xml
%feature("docstring") Bempp::ScatteredRange "";

%feature("docstring")  Bempp::ScatteredRange::ScatteredRange "";

%feature("docstring")  Bempp::ScatteredRange::ScatteredRange "";

%feature("docstring")  Bempp::ScatteredRange::empty "";

%feature("docstring")  Bempp::ScatteredRange::is_divisible "";

%feature("docstring")  Bempp::ScatteredRange::begin "";

%feature("docstring")  Bempp::ScatteredRange::end "";

%feature("docstring")  Bempp::ScatteredRange::step "";

%feature("docstring")  Bempp::ScatteredRange::size "";


// File: classBempp_1_1ScatteredRange_1_1const__iterator.xml
%feature("docstring") Bempp::ScatteredRange::const_iterator "";

%feature("docstring")
Bempp::ScatteredRange::const_iterator::const_iterator "";

%feature("docstring")  Bempp::ScatteredRange::const_iterator::value "";

%feature("docstring")  Bempp::ScatteredRange::const_iterator::step "";


// File: classBempp_1_1Solution.xml
%feature("docstring") Bempp::Solution "

This class holds the solution of a BEM computation together with
various information about the solution.

C++ includes: solution.hpp ";

%feature("docstring")  Bempp::Solution::Solution "

Constructor. ";

%feature("docstring")  Bempp::Solution::Solution "

Constructor. ";

%feature("docstring")  Bempp::Solution::gridFunction "";

%feature("docstring")  Bempp::Solution::gridFunction "";


// File: classBempp_1_1SolutionBase.xml
%feature("docstring") Bempp::SolutionBase "

The base class for the Solution and BlockedSolution container classes.

This class holds various information about the solution of a BEM
computation. It derives fromThyra::SolveStatus if Trilinos is enabled.

MagnitudeType is identical to float if ResultType is float or
complex<float>. It is double if ResultType is double or
complex<double>

C++ includes: solution_base.hpp ";

%feature("docstring")  Bempp::SolutionBase::SolutionBase "

Constructor. ";

%feature("docstring")  Bempp::SolutionBase::SolutionBase "

Constructor. ";

%feature("docstring")  Bempp::SolutionBase::status "

Return status of the linear solve. ";

%feature("docstring")  Bempp::SolutionBase::achievedTolerance "

Maximum final tolerance achieved by the linear solve.

A value of unknownTolerance() means that even an estimate of the the
final value of the tolerance is unknown. This is the typical value
returned by direct solvers. ";

%feature("docstring")  Bempp::SolutionBase::solverMessage "

Message returned by the solver. ";

%feature("docstring")  Bempp::SolutionBase::extraParameters "

Extra status parameter returned by the solver.

Contents of this list are solver-dependent. ";


// File: structBempp_1_1SolutionStatus.xml
%feature("docstring") Bempp::SolutionStatus "";


// File: classBempp_1_1Solver.xml
%feature("docstring") Bempp::Solver "

An abstract interface for various types of solvers.

This class is an interface to the solution of linear systems in BEM++.
Concrete subclasses implement specific linear solvers.

C++ includes: solver.hpp ";

%feature("docstring")  Bempp::Solver::~Solver "";

%feature("docstring")  Bempp::Solver::solve "

Solve a standard (non-blocked) boundary integral equation.

This function solves a boundary integral equation with given right-
hand side rhs of type GridFunction and returns a new Solution object.

Parameters:
-----------

rhs:   GridFunction representing the right-hand side function of the
boundary integral equation.

A new Solution object, containing the solution of the boundary
integral equation. ";

%feature("docstring")  Bempp::Solver::solve "

Solve a block-operator system of boundary integral equations.

This function solves a block system of boundary integral equations. It
takes a vector of variables of type GridFunction as its input.

Parameters:
-----------

rhs:   vector of variables of type GridFunction

A new BlockedSolution object, containing the solution of the system of
boundary integral equation. ";


// File: classBempp_1_1Space.xml
%feature("docstring") Bempp::Space "

Function space.

This class represents a space of functions defined on a grid. The
space is spanned by a finite number of scalar- or vector-valued basis
functions. The template parameter BasisFunctionType is the type of the
values of (the components of) these basis functions, and can be set to
float, double, std::complex<float> or std::complex<double>.

The basis functions of a space, also known as global degrees of
freedom (DOFs), can have support extending over multiple elements of
the grid. They are, however, composed of one or more *local* basis
functions (local degrees of freedom), each of which resides on a
single element. The mapping of local to global degrees of freedom is
triggered by calling the function assignDofs(). Many other member
functions of Space may only be invoked after assignDofs() has beeen
called.

C++ includes: space.hpp ";

/*  Attributes  */

%feature("docstring")  Bempp::Space::domainDimension "

Dimension of the grid on which functions from this space are defined.
";

%feature("docstring")  Bempp::Space::codomainDimension "

Dimension of the codomain of the functions.

In other words, number of components of the values of the functions.
(E.g. H1 space -> 1, H(curl) space on a 2D surface -> 2). ";

%feature("docstring")  Bempp::Space::grid "

Reference to the grid on which the functions from this space are
defined. ";

%feature("docstring")  Bempp::Space::basis "

Reference to the basis attached to the specified element. ";

%feature("docstring")  Bempp::Space::shapeFunctionValue "

Transformation mapping basis functions to shape functions.

This function returns a CollectionOfBasisTransformations object
consisting of a single transformation that maps values of basis
functions defined on a reference element to those of *shape functions*
defined on a particular element of the grid.

This transformation is the identity for spaces of scalar-valued
functions, but may be more complicated for spaces of vector-valued
functions, e.g. $H(\\\\mathrm{curl})$.

Todo Perhaps change the name of this method to something more
understandable, like basisToShapeFunctionTransformation. ";

/*  Element order management  */

%feature("docstring")  Bempp::Space::setElementVariant "

Set the variant of element element to variant.

The element variant determines the set of basis functions defined on
the element (e.g. maximum polynomial order). Different subclasses of
Space interpret the variant argument in different ways; for more
information, see the documentation of these subclasses.

Calling this function only makes sense for subclasses implementing
adaptive function spaces. Currently there are no such subclasses. ";

%feature("docstring")  Bempp::Space::elementVariant "

Return current variant of element element.

See the documentation of setElementVariant() for more information. ";

/*  DOF management  */

%feature("docstring")  Bempp::Space::assignDofs "

Assign global degrees of freedom to local degrees of freedom. ";

%feature("docstring")  Bempp::Space::dofsAssigned "

True if assignDofs() has been called before, false otherwise. ";

%feature("docstring")  Bempp::Space::flatLocalDofCount "

Total number of local degrees of freedom on all elements. ";

%feature("docstring")  Bempp::Space::globalDofCount "

Number of global degrees of freedom.

This function returns zero if assignDofs() has not been called before.
";

%feature("docstring")  Bempp::Space::getGlobalDofs "

Map local degrees of freedom residing on an element to global degrees
of freedom.

Parameters:
-----------

element:  An element of the grid grid().

dofs:  Indices of the global degrees of freedom corresponding to the
local degrees of freedom residing on element.

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")  Bempp::Space::global2localDofs "

Map global degrees of freedom to local degrees of freedom.

Parameters:
-----------

globalDofs:   Vector containing indices of global degrees of freedom.

localDofs:   Vector whose ith element is the vector containing all the
local degrees of freedom that are mapped to the global degree of
freedom globalDofs[i].

Note that a local degree of freedom (LocalDof) is a combination of an
EntityIndex and LocalDofIndex, as explained in its documentation.

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")  Bempp::Space::flatLocal2localDofs "

Map flat indices of local degrees of freedom to local degrees of
freedom.

Parameters:
-----------

flatLocalDofs:   Vector containing flat indices of local degrees of
freedom.

localDofs:   Vector whose ith element is the local degree of freedom
with flat index given by flatLocalDofs[i].

The result of calling this function if assignDofs() has not been
called before is undefined. ";

%feature("docstring")  Bempp::Space::getGlobalDofPositions "

Retrieve positions of global degrees of freedom.

Parameters:
-----------

positions:   Vector whose ith element contains the coordinates of the
point taken to be the \"position\" (in some sense) of ith global
degree of freedom.

This function is intended as a helper for clustering algorithms used
in matrix compression algorithms such as adaptive cross approximation.

An exception is thrown if this function is called prior to calling
assignDofs(). ";

%feature("docstring")  Bempp::Space::getFlatLocalDofPositions "

Retrieve positions of local degrees of freedom ordered by their flat
index.

Parameters:
-----------

positions:   Vector whose ith element contains the coordinates of the
point taken to be the ``position'' (in some sense) of the local degree
of freedom with flat index i.

This function is intended as a helper for clustering algorithms used
in matrix compression algorithms such as adaptive cross approximation.

An exception is thrown if this function is called prior to calling
assignDofs(). ";

%feature("docstring")  Bempp::Space::dumpClusterIds "

Write a VTK file showing the distribution of global degrees of freedom
into clusters.

Parameters:
-----------

fileName:  Name of the VTK file to be created (without extension).

clusterIdsOfGlobalDofs:   Vector whose ith element contains the
identifier of the cluster to which ith global degree has been
assigned.

This function generates a VTK file containing a single data series
mapping the ``positions'' (see globalDofPositions()) of global degrees
of freedom to the identifiers of the clusters to which these degrees
of freedom have been assigned. It is intended for debugging clustering
algorithms.

An exception is thrown if this function is called prior to calling
assignDofs(). ";

%feature("docstring")  Bempp::Space::Space "

Constructor.

Parameters:
-----------

grid:   Grid on which functions from this space should be defined.

The supplied grid must remain valid until the Space object is
destructed.

Todo The grid should be passed via a shared pointer instead of via a
reference. ";

%feature("docstring")  Bempp::Space::~Space "

Destructor. ";


// File: classBempp_1_1Vector.xml
%feature("docstring") Bempp::Vector "

Encapsulation of a vector.

If BEM++ is compiled with Trilinos, Vector is implemented by means of
Thyra::DefaultSpmdVector; otherwise an Armadillo-based fallback
implementation is used.

C++ includes: vector.hpp ";

%feature("docstring")  Bempp::Vector::Vector "

Construct a Vector from an Armadillo vector. ";

%feature("docstring")  Bempp::Vector::Vector "

Construct an uninitialized vector of length n. ";

%feature("docstring")  Bempp::Vector::size "

Vector length. ";

%feature("docstring")  Bempp::Vector::dump "

Write a textual representation of the vector to standard output. ";

%feature("docstring")  Bempp::Vector::asArmadilloVector "

Convert the Vector object into an Armadillo vector. ";


// File: classBempp_1_1VtkWriter.xml
%feature("docstring") Bempp::VtkWriter "

Abstract exporter of data in the vtk format.

Exports data (living on cells or vertices of a grid) to a file
suitable for easy visualization withThe Visualization Toolkit (VTK).

Instances of concrete subclasses of this class can be created by
GridView::vtkWriter().

C++ includes: vtk_writer.hpp ";

%feature("docstring")  Bempp::VtkWriter::~VtkWriter "

Destructor. ";

%feature("docstring")  Bempp::VtkWriter::addCellData "

Add a grid function (represented by a container) that lives on the
cells of the grid to the visualization output.

Parameters:
-----------

data:  Matrix whose ( m, n)th entry contains the value of the mth
component of the grid function in the nth cell.

name:  Name to identify the grid function. ";

%feature("docstring")  Bempp::VtkWriter::addCellData "";

%feature("docstring")  Bempp::VtkWriter::addVertexData "

Add a grid function (represented by a container) that lives on the
vertices of the grid to the visualization output.

Parameters:
-----------

data:  Matrix whose ( m, n)th entry contains the value of the mth
component of the grid function at the nth vertex.

name:  Name to identify the grid function. ";

%feature("docstring")  Bempp::VtkWriter::addVertexData "";

%feature("docstring")  Bempp::VtkWriter::clear "

Clear the list of registered functions. ";

%feature("docstring")  Bempp::VtkWriter::write "

Write output (interface might change later).

This method can be used in parallel as well as in serial programs. For
serial runs (commSize=1) it chooses other names without the
\"s####:p####:\" prefix for the .vtu/.vtp files and omits writing of
the .pvtu/pvtp file however. For parallel runs (commSize > 1) it is
the same as a call to pwrite() with path=\"\" and extendpath=\"\".

Parameters:
-----------

name:  Basic name to write (may not contain a path).

type:  Type of output (e.g,, ASCII) (optional).

Name of the created file. ";

%feature("docstring")  Bempp::VtkWriter::pwrite "

Write output (interface might change later).

\"pwrite\" means \"path write\" (i.e. write somewhere else than the
current directory). The \"p\" does not mean this method has a monopoly
on parallel writing, the regular write(const std::string &,
OutputType) method can do that just fine.

Parameters:
-----------

name:  Base name of the output files. This should not contain any
directory part or filename extensions. It will be used both for the
piece file of each process and the parallel collection file.

path:  Directory where to put the parallel collection (.pvtu/.pvtp)
file. If it is relative, it is taken relative to the current
directory.

extendpath:  Directory where to put the piece file (.vtu/.vtp) of this
process. If it is relative, it is taken relative to the directory
denoted by path.

type:  How to encode the data in the file.

Name of the created file.

Currently, extendpath may not be absolute unless path is absolute,
because that would require the value of the current directory.

Exceptions:
-----------

Dune::NotImplemented:  Extendpath is absolute but path is relative.

Dune::IOError:  Failed to open a file. ";


// File: classBempp_1_1WeakFormAcaAssemblyHelper.xml
%feature("docstring") Bempp::WeakFormAcaAssemblyHelper "

Class whose methods are called by Ahmed during assembly in the ACA
mode.

C++ includes: weak_form_aca_assembly_helper.hpp ";

%feature("docstring")
Bempp::WeakFormAcaAssemblyHelper::WeakFormAcaAssemblyHelper "";

%feature("docstring")  Bempp::WeakFormAcaAssemblyHelper::cmpbl "

Evaluate entries of a general block.

Store the entries of the block defined by b1, n1, b2, n2 (in permuted
ordering) in data. ";

%feature("docstring")  Bempp::WeakFormAcaAssemblyHelper::cmpblsym "

Evaluate entries of a symmetric block.

Store the upper part of the (symmetric) block defined by b1, n1, b1,
n1 (in permuted ordering) columnwise in data. ";

%feature("docstring")  Bempp::WeakFormAcaAssemblyHelper::scale "

Expected size of the entries in this block. ";


// File: classDune_1_1BemppStructuredGridFactory.xml
%feature("docstring") Dune::BemppStructuredGridFactory "

Construct structured cube and simplex grids in unstructured grid
managers.

Copied from Dune and slightly modified: Grids embedded in higher-
dimensional spaces are supported. In this case the last (dimworld -
dim) coordinates of all vertices, where dim is the grid dimension and
dimworld the world dimension, are set to zero.

Automatic pointers (std::unique_ptr) instead of shared pointers
(Dune::shared_ptr) are returned.

C++ includes: structured_grid_factory.hpp ";


// File: classDune_1_1BemppStructuredGridFactory_1_1MultiIndex.xml


// File: classDune_1_1BemppStructuredGridFactory_3_01YaspGrid_3_01dim_01_4_01_4.xml
%feature("docstring") Dune::BemppStructuredGridFactory< YaspGrid< dim
> > "

Specialization of the StructuredGridFactory for YaspGrid.

This allows a YaspGrid to be constructed using the
StructuredGridFactory just like the unstructured Grids. There are two
limitations: YaspGrid does not support simplices

YaspGrid only support grids which have their lower left corder at the
origin.

C++ includes: structured_grid_factory.hpp ";


// File: classFiber_1_1__1dSliceOf2dArray.xml
%feature("docstring") Fiber::_1dSliceOf2dArray "

Lightweight encapsulation of a 1D slice of a 2D array.

C++ includes: _2d_array.hpp ";

%feature("docstring")  Fiber::_1dSliceOf2dArray::_1dSliceOf2dArray "

Construct a slice consisting of the elements array(:,index1). ";

%feature("docstring")  Fiber::_1dSliceOf2dArray::self "

Returns a reference to self.

Useful to make a temporary _1dSliceOf2dArray<T> an rvalue and pass it
to a function accepting a reference to a non-const
_2dSliceOf2dArray<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::_1dSliceOf2dArray::extent "";


// File: classFiber_1_1__1dSliceOf3dArray.xml
%feature("docstring") Fiber::_1dSliceOf3dArray "

Lightweight encapsulation of a 1D slice of a 3D array.

C++ includes: _3d_array.hpp ";

%feature("docstring")  Fiber::_1dSliceOf3dArray::_1dSliceOf3dArray "

Construct a slice consisting of the elements array(:,index1,index2).
";

%feature("docstring")  Fiber::_1dSliceOf3dArray::self "

Returns a reference to self.

Useful to make a temporary _1dSliceOf3dArray<T> an rvalue and pass it
to a function accepting a reference to a non-const
_2dSliceOf3dArray<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::_1dSliceOf3dArray::extent "";


// File: classFiber_1_1__1dSliceOf4dArray.xml
%feature("docstring") Fiber::_1dSliceOf4dArray "

Lightweight encapsulation of a 1D slice of a 4d array.

C++ includes: _4d_array.hpp ";

%feature("docstring")  Fiber::_1dSliceOf4dArray::_1dSliceOf4dArray "

Construct a slice consisting of the elements
array(:,index1,index2,index3). ";

%feature("docstring")  Fiber::_1dSliceOf4dArray::self "

Returns a reference to self.

Useful to make a temporary _1dSliceOf4dArray<T> an rvalue and pass it
to a function accepting a reference to a non-const
_2dSliceOf4dArray<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::_1dSliceOf4dArray::extent "";


// File: classFiber_1_1__1dSliceOfConst2dArray.xml
%feature("docstring") Fiber::_1dSliceOfConst2dArray "

Lightweight encapsulation of a 1D slice of a constant 2D array.

C++ includes: _2d_array.hpp ";

%feature("docstring")
Fiber::_1dSliceOfConst2dArray::_1dSliceOfConst2dArray "";

%feature("docstring")  Fiber::_1dSliceOfConst2dArray::extent "";


// File: classFiber_1_1__1dSliceOfConst3dArray.xml
%feature("docstring") Fiber::_1dSliceOfConst3dArray "

Lightweight encapsulation of a 1D slice of a constant 3D array.

C++ includes: _3d_array.hpp ";

%feature("docstring")
Fiber::_1dSliceOfConst3dArray::_1dSliceOfConst3dArray "";

%feature("docstring")  Fiber::_1dSliceOfConst3dArray::extent "";


// File: classFiber_1_1__1dSliceOfConst4dArray.xml
%feature("docstring") Fiber::_1dSliceOfConst4dArray "

Lightweight encapsulation of a 2D slice of a constant 4d array.

C++ includes: _4d_array.hpp ";

%feature("docstring")
Fiber::_1dSliceOfConst4dArray::_1dSliceOfConst4dArray "";

%feature("docstring")  Fiber::_1dSliceOfConst4dArray::extent "";


// File: classFiber_1_1__2dArray.xml
%feature("docstring") Fiber::_2dArray "

Simple implementation of a 2D Fortran-ordered array.

Bound checking can optionally be activated by defining the symbol
FIBER_CHECK_ARRAY_BOUNDS.

C++ includes: _2d_array.hpp ";

%feature("docstring")  Fiber::_2dArray::_2dArray "";

%feature("docstring")  Fiber::_2dArray::_2dArray "";

%feature("docstring")  Fiber::_2dArray::_2dArray "";

%feature("docstring")  Fiber::_2dArray::_2dArray "";

%feature("docstring")  Fiber::_2dArray::~_2dArray "";

%feature("docstring")  Fiber::_2dArray::extent "";

%feature("docstring")  Fiber::_2dArray::set_size "";

%feature("docstring")  Fiber::_2dArray::begin "";

%feature("docstring")  Fiber::_2dArray::begin "";

%feature("docstring")  Fiber::_2dArray::end "";

%feature("docstring")  Fiber::_2dArray::end "";


// File: classFiber_1_1__2dSliceOf3dArray.xml
%feature("docstring") Fiber::_2dSliceOf3dArray "

Lightweight encapsulation of a 2D slice of a 3D array.

C++ includes: _3d_array.hpp ";

%feature("docstring")  Fiber::_2dSliceOf3dArray::_2dSliceOf3dArray "";

%feature("docstring")  Fiber::_2dSliceOf3dArray::self "

Returns a reference to self.

Useful to make a temporary _2dSliceOf3dArray<T> an rvalue and pass it
to a function accepting a reference to a non-const
_2dSliceOf3dArray<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::_2dSliceOf3dArray::extent "";


// File: classFiber_1_1__2dSliceOf4dArray.xml
%feature("docstring") Fiber::_2dSliceOf4dArray "

Lightweight encapsulation of a 2D slice of a 4d array.

C++ includes: _4d_array.hpp ";

%feature("docstring")  Fiber::_2dSliceOf4dArray::_2dSliceOf4dArray "";

%feature("docstring")  Fiber::_2dSliceOf4dArray::self "

Returns a reference to self.

Useful to make a temporary _2dSliceOf4dArray<T> an rvalue and pass it
to a function accepting a reference to a non-const
_2dSliceOf4dArray<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::_2dSliceOf4dArray::extent "";


// File: classFiber_1_1__2dSliceOfConst3dArray.xml
%feature("docstring") Fiber::_2dSliceOfConst3dArray "

Lightweight encapsulation of a 2D slice of a constant 3D array.

C++ includes: _3d_array.hpp ";

%feature("docstring")
Fiber::_2dSliceOfConst3dArray::_2dSliceOfConst3dArray "";

%feature("docstring")  Fiber::_2dSliceOfConst3dArray::extent "";


// File: classFiber_1_1__2dSliceOfConst4dArray.xml
%feature("docstring") Fiber::_2dSliceOfConst4dArray "

Lightweight encapsulation of a 2D slice of a constant 4d array.

C++ includes: _4d_array.hpp ";

%feature("docstring")
Fiber::_2dSliceOfConst4dArray::_2dSliceOfConst4dArray "";

%feature("docstring")  Fiber::_2dSliceOfConst4dArray::extent "";


// File: classFiber_1_1__3dArray.xml
%feature("docstring") Fiber::_3dArray "

Simple implementation of a 3D Fortran-ordered array.

Bound checking can optionally be activated by defining the symbol
FIBER_CHECK_ARRAY_BOUNDS.

C++ includes: _3d_array.hpp ";

%feature("docstring")  Fiber::_3dArray::_3dArray "";

%feature("docstring")  Fiber::_3dArray::_3dArray "";

%feature("docstring")  Fiber::_3dArray::_3dArray "";

%feature("docstring")  Fiber::_3dArray::~_3dArray "";

%feature("docstring")  Fiber::_3dArray::extent "";

%feature("docstring")  Fiber::_3dArray::set_size "";

%feature("docstring")  Fiber::_3dArray::begin "";

%feature("docstring")  Fiber::_3dArray::begin "";

%feature("docstring")  Fiber::_3dArray::end "";

%feature("docstring")  Fiber::_3dArray::end "";


// File: classFiber_1_1__3dSliceOf4dArray.xml
%feature("docstring") Fiber::_3dSliceOf4dArray "

Lightweight encapsulation of a 3D slice of a 4D array.

C++ includes: _4d_array.hpp ";

%feature("docstring")  Fiber::_3dSliceOf4dArray::_3dSliceOf4dArray "";

%feature("docstring")  Fiber::_3dSliceOf4dArray::self "

Returns a reference to self.

Useful to make a temporary _3dSliceOf4dArray<T> an rvalue and pass it
to a function accepting a reference to a non-const
_3dSliceOf4dArray<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::_3dSliceOf4dArray::extent "";


// File: classFiber_1_1__3dSliceOfConst4dArray.xml
%feature("docstring") Fiber::_3dSliceOfConst4dArray "

Lightweight encapsulation of a 2D slice of a constant 4d array.

C++ includes: _4d_array.hpp ";

%feature("docstring")
Fiber::_3dSliceOfConst4dArray::_3dSliceOfConst4dArray "";

%feature("docstring")  Fiber::_3dSliceOfConst4dArray::extent "";


// File: classFiber_1_1__4dArray.xml
%feature("docstring") Fiber::_4dArray "

Simple implementation of a 4D Fortran-ordered array.

Bound checking can optionally be activated by defining the symbol
FIBER_CHECK_ARRAY_BOUNDS.

C++ includes: _4d_array.hpp ";

%feature("docstring")  Fiber::_4dArray::_4dArray "";

%feature("docstring")  Fiber::_4dArray::_4dArray "";

%feature("docstring")  Fiber::_4dArray::_4dArray "";

%feature("docstring")  Fiber::_4dArray::~_4dArray "";

%feature("docstring")  Fiber::_4dArray::extent "";

%feature("docstring")  Fiber::_4dArray::set_size "";

%feature("docstring")  Fiber::_4dArray::begin "";

%feature("docstring")  Fiber::_4dArray::begin "";

%feature("docstring")  Fiber::_4dArray::end "";

%feature("docstring")  Fiber::_4dArray::end "";


// File: structFiber_1_1AccuracyOptions.xml
%feature("docstring") Fiber::AccuracyOptions "

Options controlling quadrature accuracy.

C++ includes: accuracy_options.hpp ";


// File: classFiber_1_1Basis.xml
%feature("docstring") Fiber::Basis "";

%feature("docstring")  Fiber::Basis::~Basis "";

%feature("docstring")  Fiber::Basis::size "";

%feature("docstring")  Fiber::Basis::order "

Maximum polynomial order of basis elements. ";

%feature("docstring")  Fiber::Basis::evaluate "";

%feature("docstring")  Fiber::Basis::clCodeString "

Returns an OpenCL code snippet for basis function evaluation.

The code snippet must provide device function devBasisEval ";


// File: structFiber_1_1BasisData.xml
%feature("docstring") Fiber::BasisData "";

%feature("docstring")  Fiber::BasisData::componentCount "";

%feature("docstring")  Fiber::BasisData::functionCount "";

%feature("docstring")  Fiber::BasisData::pointCount "";

%feature("docstring")  Fiber::BasisData::const_slice "";


// File: structFiber_1_1Coercion.xml
%feature("docstring") Fiber::Coercion "

\"Larger\" of the types U and V.

C++ includes: scalar_traits.hpp ";


// File: structFiber_1_1Coercion_3_01double_00_01double_01_4.xml
%feature("docstring") Fiber::Coercion< double, double > " ";


// File: structFiber_1_1Coercion_3_01double_00_01std_1_1complex_3_01double_01_4_01_4.xml
%feature("docstring") Fiber::Coercion< double, std::complex< double >
> " ";


// File: structFiber_1_1Coercion_3_01float_00_01float_01_4.xml
%feature("docstring") Fiber::Coercion< float, float > " ";


// File: structFiber_1_1Coercion_3_01float_00_01std_1_1complex_3_01float_01_4_01_4.xml
%feature("docstring") Fiber::Coercion< float, std::complex< float > >
" ";


// File: structFiber_1_1Coercion_3_01std_1_1complex_3_01double_01_4_00_01double_01_4.xml
%feature("docstring") Fiber::Coercion< std::complex< double >, double
> " ";


// File: structFiber_1_1Coercion_3_01std_1_1complex_3_01double_01_4_00_01std_1_1complex_3_01double_01_4_01_4.xml
%feature("docstring") Fiber::Coercion< std::complex< double >,
std::complex< double > > " ";


// File: structFiber_1_1Coercion_3_01std_1_1complex_3_01float_01_4_00_01float_01_4.xml
%feature("docstring") Fiber::Coercion< std::complex< float >, float >
" ";


// File: structFiber_1_1Coercion_3_01std_1_1complex_3_01float_01_4_00_01std_1_1complex_3_01float_01_4_01_4.xml
%feature("docstring") Fiber::Coercion< std::complex< float >,
std::complex< float > > " ";


// File: classFiber_1_1CollectionOf1dSlicesOf2dArrays.xml
%feature("docstring") Fiber::CollectionOf1dSlicesOf2dArrays "";

%feature("docstring")
Fiber::CollectionOf1dSlicesOf2dArrays::CollectionOf1dSlicesOf2dArrays
"";

%feature("docstring")  Fiber::CollectionOf1dSlicesOf2dArrays::self "

Returns a reference to self.

Useful to make a temporary CollectionOf1dSlicesOf2dArrays<T> an rvalue
and pass it to a function accepting a reference to a non-const
CollectionOf1dSlicesOf2dArrays<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::CollectionOf1dSlicesOf2dArrays::size "";


// File: classFiber_1_1CollectionOf1dSlicesOf3dArrays.xml
%feature("docstring") Fiber::CollectionOf1dSlicesOf3dArrays "";

%feature("docstring")
Fiber::CollectionOf1dSlicesOf3dArrays::CollectionOf1dSlicesOf3dArrays
"";

%feature("docstring")  Fiber::CollectionOf1dSlicesOf3dArrays::self "

Returns a reference to self.

Useful to make a temporary CollectionOf1dSlicesOf3dArrays<T> an rvalue
and pass it to a function accepting a reference to a non-const
CollectionOf1dSlicesOf3dArrays<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::CollectionOf1dSlicesOf3dArrays::size "";


// File: classFiber_1_1CollectionOf1dSlicesOf4dArrays.xml
%feature("docstring") Fiber::CollectionOf1dSlicesOf4dArrays "";

%feature("docstring")
Fiber::CollectionOf1dSlicesOf4dArrays::CollectionOf1dSlicesOf4dArrays
"";

%feature("docstring")  Fiber::CollectionOf1dSlicesOf4dArrays::self "

Returns a reference to self.

Useful to make a temporary CollectionOf1dSlicesOf4dArrays<T> an rvalue
and pass it to a function accepting a reference to a non-const
CollectionOf1dSlicesOf4dArrays<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::CollectionOf1dSlicesOf4dArrays::size "";


// File: classFiber_1_1CollectionOf1dSlicesOfConst2dArrays.xml
%feature("docstring") Fiber::CollectionOf1dSlicesOfConst2dArrays "";

%feature("docstring")
Fiber::CollectionOf1dSlicesOfConst2dArrays::CollectionOf1dSlicesOfConst2dArrays
"";

%feature("docstring")
Fiber::CollectionOf1dSlicesOfConst2dArrays::size "";


// File: classFiber_1_1CollectionOf1dSlicesOfConst3dArrays.xml
%feature("docstring") Fiber::CollectionOf1dSlicesOfConst3dArrays "";

%feature("docstring")
Fiber::CollectionOf1dSlicesOfConst3dArrays::CollectionOf1dSlicesOfConst3dArrays
"";

%feature("docstring")
Fiber::CollectionOf1dSlicesOfConst3dArrays::size "";


// File: classFiber_1_1CollectionOf1dSlicesOfConst4dArrays.xml
%feature("docstring") Fiber::CollectionOf1dSlicesOfConst4dArrays "";

%feature("docstring")
Fiber::CollectionOf1dSlicesOfConst4dArrays::CollectionOf1dSlicesOfConst4dArrays
"";

%feature("docstring")
Fiber::CollectionOf1dSlicesOfConst4dArrays::size "";


// File: classFiber_1_1CollectionOf2dArrays.xml
%feature("docstring") Fiber::CollectionOf2dArrays "";

%feature("docstring")
Fiber::CollectionOf2dArrays::CollectionOf2dArrays "";

%feature("docstring")
Fiber::CollectionOf2dArrays::CollectionOf2dArrays "";

%feature("docstring")
Fiber::CollectionOf2dArrays::CollectionOf2dArrays "";

%feature("docstring")  Fiber::CollectionOf2dArrays::set_size "";

%feature("docstring")  Fiber::CollectionOf2dArrays::size "";

%feature("docstring")  Fiber::CollectionOf2dArrays::fill "";

%feature("docstring")  Fiber::CollectionOf2dArrays::slice "";

%feature("docstring")  Fiber::CollectionOf2dArrays::const_slice "";


// File: classFiber_1_1CollectionOf2dSlicesOf3dArrays.xml
%feature("docstring") Fiber::CollectionOf2dSlicesOf3dArrays "";

%feature("docstring")
Fiber::CollectionOf2dSlicesOf3dArrays::CollectionOf2dSlicesOf3dArrays
"";

%feature("docstring")  Fiber::CollectionOf2dSlicesOf3dArrays::self "

Returns a reference to self.

Useful to make a temporary CollectionOf2dSlicesOf3dArrays<T> an rvalue
and pass it to a function accepting a reference to a non-const
CollectionOf2dSlicesOf3dArrays<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::CollectionOf2dSlicesOf3dArrays::size "";


// File: classFiber_1_1CollectionOf2dSlicesOf4dArrays.xml
%feature("docstring") Fiber::CollectionOf2dSlicesOf4dArrays "";

%feature("docstring")
Fiber::CollectionOf2dSlicesOf4dArrays::CollectionOf2dSlicesOf4dArrays
"";

%feature("docstring")  Fiber::CollectionOf2dSlicesOf4dArrays::self "

Returns a reference to self.

Useful to make a temporary CollectionOf2dSlicesOf4dArrays<T> an rvalue
and pass it to a function accepting a reference to a non-const
CollectionOf2dSlicesOf4dArrays<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::CollectionOf2dSlicesOf4dArrays::size "";


// File: classFiber_1_1CollectionOf2dSlicesOfConst3dArrays.xml
%feature("docstring") Fiber::CollectionOf2dSlicesOfConst3dArrays "";

%feature("docstring")
Fiber::CollectionOf2dSlicesOfConst3dArrays::CollectionOf2dSlicesOfConst3dArrays
"";

%feature("docstring")
Fiber::CollectionOf2dSlicesOfConst3dArrays::size "";


// File: classFiber_1_1CollectionOf2dSlicesOfConst4dArrays.xml
%feature("docstring") Fiber::CollectionOf2dSlicesOfConst4dArrays "";

%feature("docstring")
Fiber::CollectionOf2dSlicesOfConst4dArrays::CollectionOf2dSlicesOfConst4dArrays
"";

%feature("docstring")
Fiber::CollectionOf2dSlicesOfConst4dArrays::size "";


// File: classFiber_1_1CollectionOf3dArrays.xml
%feature("docstring") Fiber::CollectionOf3dArrays "";

%feature("docstring")
Fiber::CollectionOf3dArrays::CollectionOf3dArrays "";

%feature("docstring")
Fiber::CollectionOf3dArrays::CollectionOf3dArrays "";

%feature("docstring")  Fiber::CollectionOf3dArrays::set_size "";

%feature("docstring")  Fiber::CollectionOf3dArrays::size "";

%feature("docstring")  Fiber::CollectionOf3dArrays::fill "";

%feature("docstring")  Fiber::CollectionOf3dArrays::slice "";

%feature("docstring")  Fiber::CollectionOf3dArrays::const_slice "";

%feature("docstring")  Fiber::CollectionOf3dArrays::slice "";

%feature("docstring")  Fiber::CollectionOf3dArrays::const_slice "";


// File: classFiber_1_1CollectionOf3dSlicesOf4dArrays.xml
%feature("docstring") Fiber::CollectionOf3dSlicesOf4dArrays "";

%feature("docstring")
Fiber::CollectionOf3dSlicesOf4dArrays::CollectionOf3dSlicesOf4dArrays
"";

%feature("docstring")  Fiber::CollectionOf3dSlicesOf4dArrays::self "

Returns a reference to self.

Useful to make a temporary CollectionOf3dSlicesOf4dArrays<T> an rvalue
and pass it to a function accepting a reference to a non-const
CollectionOf3dSlicesOf4dArrays<T>.

Once we switch to C++11, this function can be removed because of the
new support for rvalue references. ";

%feature("docstring")  Fiber::CollectionOf3dSlicesOf4dArrays::size "";


// File: classFiber_1_1CollectionOf3dSlicesOfConst4dArrays.xml
%feature("docstring") Fiber::CollectionOf3dSlicesOfConst4dArrays "";

%feature("docstring")
Fiber::CollectionOf3dSlicesOfConst4dArrays::CollectionOf3dSlicesOfConst4dArrays
"";

%feature("docstring")
Fiber::CollectionOf3dSlicesOfConst4dArrays::size "";


// File: classFiber_1_1CollectionOf4dArrays.xml
%feature("docstring") Fiber::CollectionOf4dArrays "";

%feature("docstring")
Fiber::CollectionOf4dArrays::CollectionOf4dArrays "";

%feature("docstring")
Fiber::CollectionOf4dArrays::CollectionOf4dArrays "";

%feature("docstring")  Fiber::CollectionOf4dArrays::set_size "";

%feature("docstring")  Fiber::CollectionOf4dArrays::size "";

%feature("docstring")  Fiber::CollectionOf4dArrays::fill "";

%feature("docstring")  Fiber::CollectionOf4dArrays::slice "";

%feature("docstring")  Fiber::CollectionOf4dArrays::const_slice "";

%feature("docstring")  Fiber::CollectionOf4dArrays::slice "";

%feature("docstring")  Fiber::CollectionOf4dArrays::const_slice "";

%feature("docstring")  Fiber::CollectionOf4dArrays::slice "";

%feature("docstring")  Fiber::CollectionOf4dArrays::const_slice "";


// File: classFiber_1_1CollectionOfBasisTransformations.xml
%feature("docstring") Fiber::CollectionOfBasisTransformations "";

%feature("docstring")
Fiber::CollectionOfBasisTransformations::~CollectionOfBasisTransformations
"";

%feature("docstring")
Fiber::CollectionOfBasisTransformations::transformationCount "";

%feature("docstring")
Fiber::CollectionOfBasisTransformations::argumentDimension "";

%feature("docstring")
Fiber::CollectionOfBasisTransformations::resultDimension "";

%feature("docstring")
Fiber::CollectionOfBasisTransformations::addDependencies "";

%feature("docstring")
Fiber::CollectionOfBasisTransformations::evaluate "

Evaluate basis function transformations at specified points.

Parameters:
-----------

result:  Result. Collection of 3D arrays with dimensions (codomainDim,
functionCount, pointCount). ";

%feature("docstring")
Fiber::CollectionOfBasisTransformations::evaluate "";


// File: classFiber_1_1CollectionOfKernels.xml
%feature("docstring") Fiber::CollectionOfKernels "";

%feature("docstring")
Fiber::CollectionOfKernels::~CollectionOfKernels "";

%feature("docstring")
Fiber::CollectionOfKernels::addGeometricalDependencies "";

%feature("docstring")
Fiber::CollectionOfKernels::evaluateAtPointPairs "";

%feature("docstring")  Fiber::CollectionOfKernels::evaluateOnGrid "";

%feature("docstring")  Fiber::CollectionOfKernels::evaluateClCode "

Returns an OpenCL code snippet for kernel evaluation as a string.

The code snippet must provide device functions devKernevalGrid and
devKernevalPair (for an implementation example, see
CL/laplace_3d_single_layer_potential_kernel.cl)

The required data must have been pushed to device memory before
invocation. ";


// File: classFiber_1_1ConstBasisDataSlice.xml
%feature("docstring") Fiber::ConstBasisDataSlice "";

%feature("docstring")  Fiber::ConstBasisDataSlice::ConstBasisDataSlice
"";

%feature("docstring")  Fiber::ConstBasisDataSlice::values "";

%feature("docstring")  Fiber::ConstBasisDataSlice::derivatives "";

%feature("docstring")  Fiber::ConstBasisDataSlice::componentCount "";


// File: classFiber_1_1ConstGeometricalDataSlice.xml
%feature("docstring") Fiber::ConstGeometricalDataSlice "";

%feature("docstring")
Fiber::ConstGeometricalDataSlice::ConstGeometricalDataSlice "";

%feature("docstring")  Fiber::ConstGeometricalDataSlice::global "";

%feature("docstring")
Fiber::ConstGeometricalDataSlice::integrationElement "";

%feature("docstring")
Fiber::ConstGeometricalDataSlice::jacobianTransposed "";

%feature("docstring")
Fiber::ConstGeometricalDataSlice::jacobianInverseTransposed "";

%feature("docstring")  Fiber::ConstGeometricalDataSlice::normal "";

%feature("docstring")  Fiber::ConstGeometricalDataSlice::dimWorld "";


// File: classFiber_1_1DefaultCollectionOfBasisTransformations.xml
%feature("docstring") Fiber::DefaultCollectionOfBasisTransformations "";

%feature("docstring")
Fiber::DefaultCollectionOfBasisTransformations::DefaultCollectionOfBasisTransformations
"";

%feature("docstring")
Fiber::DefaultCollectionOfBasisTransformations::transformationCount "";

%feature("docstring")
Fiber::DefaultCollectionOfBasisTransformations::argumentDimension "";

%feature("docstring")
Fiber::DefaultCollectionOfBasisTransformations::resultDimension "";

%feature("docstring")
Fiber::DefaultCollectionOfBasisTransformations::addDependencies "";


// File: classFiber_1_1DefaultCollectionOfKernels.xml
%feature("docstring") Fiber::DefaultCollectionOfKernels "";

%feature("docstring")
Fiber::DefaultCollectionOfKernels::DefaultCollectionOfKernels "";

%feature("docstring")  Fiber::DefaultCollectionOfKernels::functor "";

%feature("docstring")  Fiber::DefaultCollectionOfKernels::functor "";

%feature("docstring")
Fiber::DefaultCollectionOfKernels::addGeometricalDependencies "";

%feature("docstring")
Fiber::DefaultCollectionOfKernels::evaluateAtPointPairs "";

%feature("docstring")
Fiber::DefaultCollectionOfKernels::evaluateOnGrid "";

%feature("docstring")
Fiber::DefaultCollectionOfKernels::evaluateClCode "";


// File: classFiber_1_1DefaultEvaluatorForIntegralOperators.xml
%feature("docstring") Fiber::DefaultEvaluatorForIntegralOperators "";

%feature("docstring")
Fiber::DefaultEvaluatorForIntegralOperators::DefaultEvaluatorForIntegralOperators
"";

%feature("docstring")
Fiber::DefaultEvaluatorForIntegralOperators::evaluate "";


// File: classFiber_1_1DefaultKernelTrialIntegral.xml
%feature("docstring") Fiber::DefaultKernelTrialIntegral "";

%feature("docstring")
Fiber::DefaultKernelTrialIntegral::DefaultKernelTrialIntegral "";

%feature("docstring")
Fiber::DefaultKernelTrialIntegral::resultDimension "";

%feature("docstring")
Fiber::DefaultKernelTrialIntegral::addGeometricalDependencies "";

%feature("docstring")  Fiber::DefaultKernelTrialIntegral::evaluate "";


// File: classFiber_1_1DefaultLocalAssemblerForGridFunctionsOnSurfaces.xml
%feature("docstring")
Fiber::DefaultLocalAssemblerForGridFunctionsOnSurfaces "";

%feature("docstring")
Fiber::DefaultLocalAssemblerForGridFunctionsOnSurfaces::DefaultLocalAssemblerForGridFunctionsOnSurfaces
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForGridFunctionsOnSurfaces::~DefaultLocalAssemblerForGridFunctionsOnSurfaces
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForGridFunctionsOnSurfaces::evaluateLocalWeakForms
"";


// File: classFiber_1_1DefaultLocalAssemblerForIdentityOperatorOnSurface.xml
%feature("docstring")
Fiber::DefaultLocalAssemblerForIdentityOperatorOnSurface "";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIdentityOperatorOnSurface::DefaultLocalAssemblerForIdentityOperatorOnSurface
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIdentityOperatorOnSurface::evaluateLocalWeakForms
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIdentityOperatorOnSurface::evaluateLocalWeakForms
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIdentityOperatorOnSurface::evaluateLocalWeakForms
"";


// File: classFiber_1_1DefaultLocalAssemblerForIntegralOperatorsOnSurfaces.xml
%feature("docstring")
Fiber::DefaultLocalAssemblerForIntegralOperatorsOnSurfaces "";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIntegralOperatorsOnSurfaces::DefaultLocalAssemblerForIntegralOperatorsOnSurfaces
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIntegralOperatorsOnSurfaces::~DefaultLocalAssemblerForIntegralOperatorsOnSurfaces
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIntegralOperatorsOnSurfaces::evaluateLocalWeakForms
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIntegralOperatorsOnSurfaces::evaluateLocalWeakForms
"";

%feature("docstring")
Fiber::DefaultLocalAssemblerForIntegralOperatorsOnSurfaces::evaluateLocalWeakForms
"";


// File: classFiber_1_1DefaultTestKernelTrialIntegral.xml
%feature("docstring") Fiber::DefaultTestKernelTrialIntegral "

Standard implementation of the TestKernelTrialIntegral interface.

The evaluate*() member functions can be used to evaluate integrals of
the form

\\\\[ \\\\int_{\\\\Gamma_i} dx \\\\int_{\\\\Gamma_j} dy \\\\, I[f(x),
g(y)] \\\\],

where the integrand $I(x, y)$ depends in an arbitrary way on the test
function $f(x)$ and the trial function $f(y)$.

This class template takes a single template parameter,
IntegrandFunctor, which should stand for a type providing the
following interface:

The addGeometricalDependencies() method should specify any geometrical
data on which the integral depends explicitly (not through the kernels
or basis function transformations). For example, if the integrand
depends on the vectors normal to the surface at test and trial points,
the function could have the form

The evaluate() method should compute the integrand -- excluding the
quadrature weights! -- at a single (test point, trial point) pair. It
is supplied with the following parameters:

Parameters:
-----------

testGeomData:  Geometric data at a single test point.

trialGeomData:  Geometric data at a single trial point.

testTransformations:  Values of a collection of transformations of a
single test function at the test point.

trialTransformations:  Values of a collection of transformations of a
single trial function at the trial point.

kernels:  Values of a collection of kernels at the (test point, trial
point) pair.

Todo Perhaps implement IntegrandFunctor using the curiously recurring
template pattern.

C++ includes: default_test_kernel_trial_integral.hpp ";

%feature("docstring")
Fiber::DefaultTestKernelTrialIntegral::DefaultTestKernelTrialIntegral
"";

%feature("docstring")
Fiber::DefaultTestKernelTrialIntegral::addGeometricalDependencies "";

%feature("docstring")
Fiber::DefaultTestKernelTrialIntegral::evaluateWithTensorQuadratureRule
"";

%feature("docstring")
Fiber::DefaultTestKernelTrialIntegral::evaluateWithNontensorQuadratureRule
"";


// File: structFiber_1_1DoubleQuadratureDescriptor.xml
%feature("docstring") Fiber::DoubleQuadratureDescriptor "";


// File: classFiber_1_1ElementaryBasisTransformationFunctorPairWrapper.xml
%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorPairWrapper "";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorPairWrapper::transformationCount
"";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorPairWrapper::argumentDimension
"";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorPairWrapper::resultDimension
"";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorPairWrapper::addDependencies
"";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorPairWrapper::evaluate "";


// File: classFiber_1_1ElementaryBasisTransformationFunctorWrapper.xml
%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorWrapper "";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorWrapper::transformationCount
"";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorWrapper::argumentDimension
"";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorWrapper::resultDimension "";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorWrapper::addDependencies "";

%feature("docstring")
Fiber::ElementaryBasisTransformationFunctorWrapper::evaluate "";


// File: structFiber_1_1ElementPairTopology.xml
%feature("docstring") Fiber::ElementPairTopology "";

%feature("docstring")  Fiber::ElementPairTopology::ElementPairTopology
"";


// File: classFiber_1_1EvaluatorForIntegralOperators.xml
%feature("docstring") Fiber::EvaluatorForIntegralOperators "";

%feature("docstring")
Fiber::EvaluatorForIntegralOperators::~EvaluatorForIntegralOperators "";

%feature("docstring")  Fiber::EvaluatorForIntegralOperators::evaluate
"";


// File: classFiber_1_1Function.xml
%feature("docstring") Fiber::Function "

Function to be used as a source term.

C++ includes: function.hpp ";

%feature("docstring")  Fiber::Function::~Function "";

%feature("docstring")  Fiber::Function::worldDimension "";

%feature("docstring")  Fiber::Function::codomainDimension "";

%feature("docstring")  Fiber::Function::addGeometricalDependencies "";

%feature("docstring")  Fiber::Function::evaluate "";


// File: structFiber_1_1GeometricalData.xml
%feature("docstring") Fiber::GeometricalData "";

%feature("docstring")  Fiber::GeometricalData::pointCount "";

%feature("docstring")  Fiber::GeometricalData::dimWorld "";

%feature("docstring")  Fiber::GeometricalData::const_slice "";


// File: classFiber_1_1KernelTrialIntegral.xml
%feature("docstring") Fiber::KernelTrialIntegral "";

%feature("docstring")
Fiber::KernelTrialIntegral::~KernelTrialIntegral "";

%feature("docstring")  Fiber::KernelTrialIntegral::resultDimension "";

%feature("docstring")
Fiber::KernelTrialIntegral::addGeometricalDependencies "";

%feature("docstring")  Fiber::KernelTrialIntegral::evaluate "";


// File: classFiber_1_1Laplace3dAdjointDoubleLayerPotentialKernelFunctor.xml
%feature("docstring")
Fiber::Laplace3dAdjointDoubleLayerPotentialKernelFunctor "

Adjoint double-layer-potential kernel functor for the Laplace equation
in 3D.

ValueType Type used to represent the values of the kernel. It can be
one of: float, double, std::complex<float> and std::complex<double>.

See:   Laplace equation in 3D

C++ includes:
laplace_3d_adjoint_double_layer_potential_kernel_functor.hpp ";

%feature("docstring")
Fiber::Laplace3dAdjointDoubleLayerPotentialKernelFunctor::kernelCount
"";

%feature("docstring")
Fiber::Laplace3dAdjointDoubleLayerPotentialKernelFunctor::kernelRowCount
"";

%feature("docstring")
Fiber::Laplace3dAdjointDoubleLayerPotentialKernelFunctor::kernelColCount
"";

%feature("docstring")
Fiber::Laplace3dAdjointDoubleLayerPotentialKernelFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::Laplace3dAdjointDoubleLayerPotentialKernelFunctor::evaluate "";


// File: classFiber_1_1Laplace3dDoubleLayerPotentialKernelFunctor.xml
%feature("docstring")
Fiber::Laplace3dDoubleLayerPotentialKernelFunctor "

Double-layer-potential kernel functor for the Laplace equation in 3D.

ValueType Type used to represent the values of the kernel. It can be
one of: float, double, std::complex<float> and std::complex<double>.

See:   Laplace equation in 3D

C++ includes: laplace_3d_double_layer_potential_kernel_functor.hpp ";

%feature("docstring")
Fiber::Laplace3dDoubleLayerPotentialKernelFunctor::kernelCount "";

%feature("docstring")
Fiber::Laplace3dDoubleLayerPotentialKernelFunctor::kernelRowCount "";

%feature("docstring")
Fiber::Laplace3dDoubleLayerPotentialKernelFunctor::kernelColCount "";

%feature("docstring")
Fiber::Laplace3dDoubleLayerPotentialKernelFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::Laplace3dDoubleLayerPotentialKernelFunctor::evaluate "";


// File: classFiber_1_1Laplace3dSingleLayerPotentialKernelFunctor.xml
%feature("docstring")
Fiber::Laplace3dSingleLayerPotentialKernelFunctor "

Single-layer-potential kernel functor for the Laplace equation in 3D.

ValueType Type used to represent the values of the kernel. It can be
one of: float, double, std::complex<float> and std::complex<double>.

See:   Laplace equation in 3D

C++ includes: laplace_3d_single_layer_potential_kernel_functor.hpp ";

%feature("docstring")
Fiber::Laplace3dSingleLayerPotentialKernelFunctor::kernelCount "";

%feature("docstring")
Fiber::Laplace3dSingleLayerPotentialKernelFunctor::kernelRowCount "";

%feature("docstring")
Fiber::Laplace3dSingleLayerPotentialKernelFunctor::kernelColCount "";

%feature("docstring")
Fiber::Laplace3dSingleLayerPotentialKernelFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::Laplace3dSingleLayerPotentialKernelFunctor::evaluate "";


// File: classFiber_1_1LocalAssemblerForGridFunctions.xml
%feature("docstring") Fiber::LocalAssemblerForGridFunctions "

Local assembler for grid functions.

This assembler provides methods that evaluate local (element-by-
element) weak forms of integrals occurring in boundary-element
matrices of grid functions.

C++ includes: local_assembler_for_grid_functions.hpp ";

%feature("docstring")
Fiber::LocalAssemblerForGridFunctions::~LocalAssemblerForGridFunctions
"";

%feature("docstring")
Fiber::LocalAssemblerForGridFunctions::evaluateLocalWeakForms "

Assemble local weak forms of a source term on specified elements. ";


// File: classFiber_1_1LocalAssemblerForOperators.xml
%feature("docstring") Fiber::LocalAssemblerForOperators "

Abstract interface of a local assembler for operators.

A local assembler constructs local (element-by-element) matrix
representations of linear operators used in boundary-element methods.

Typically, a separate local assembler must be constructed for each
elementary integral operator and for the identity operator.

Concrete subclasses of this interface class automatically select
integrators well-adapted for evaluation of specific integrals
occurring in matrix representations of different classes of operators.

C++ includes: local_assembler_for_operators.hpp ";

%feature("docstring")
Fiber::LocalAssemblerForOperators::~LocalAssemblerForOperators "";

%feature("docstring")
Fiber::LocalAssemblerForOperators::evaluateLocalWeakForms "

Number of dimensions over which integration takes place.

Assemble local weak forms.

In this overload, a \"column\" of local weak forms is assembled. More
specifically, on exit result is a vector of local weak forms
corresponding to the following pairs of elements:

if callVariant is TEST_TRIAL, all pairs ( elementA, elementB) for
elementA in elementsA;

if callVariant is TRIAL_TEST, all pairs ( elementB, elementA) for
elementA in elementsA.

Unless localDofIndexB is set to ALL_DOFS, only entries corresponding
to the ( localDofIndexB)th local DOF on elementB are calculated. ";

%feature("docstring")
Fiber::LocalAssemblerForOperators::evaluateLocalWeakForms "

Assemble local weak forms.

This overload constructs and assigns to the output parameter result
the 2D array of local weak forms corresponding to all pairs (
testElement, trialElement) with testElement in testElementIndices and
trialElement in trialElementIndices.

This function should be used primarily for small blocks of elements
lying close to each other. ";

%feature("docstring")
Fiber::LocalAssemblerForOperators::evaluateLocalWeakForms "

Assemble local weak forms.

Parameters:
-----------

elementIndices:  Vector of element indices.

result:  Vector of weak forms of the operator on element pairs (
element( i), element( i)) for i in elementIndices. ";


// File: classFiber_1_1ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor.xml
%feature("docstring")
Fiber::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor "

Adjoint double-layer-potential kernel functor for the modified
Helmholtz equation in 3D.

ValueType Type used to represent the values of the kernel. It can be
one of: float, double, std::complex<float> and std::complex<double>.
Note that setting ValueType to a real type implies that the wave
number will also be purely real.

See:   Modified Helmholtz equation in 3D

C++ includes:
modified_helmholtz_3d_adjoint_double_layer_potential_kernel_functor.hpp
";

%feature("docstring")
Fiber::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor::kernelCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor::kernelRowCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor::kernelColCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor::waveNumber
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dAdjointDoubleLayerPotentialKernelFunctor::evaluate
"";


// File: classFiber_1_1ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor.xml
%feature("docstring")
Fiber::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor "

Double-layer-potential kernel functor for the modified Helmholtz
equation in 3D.

ValueType Type used to represent the values of the kernel. It can be
one of: float, double, std::complex<float> and std::complex<double>.
Note that setting ValueType to a real type implies that the wave
number will also be purely real.

See:   Modified Helmholtz equation in 3D

C++ includes:
modified_helmholtz_3d_double_layer_potential_kernel_functor.hpp ";

%feature("docstring")
Fiber::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor::kernelCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor::kernelRowCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor::kernelColCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor::waveNumber
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dDoubleLayerPotentialKernelFunctor::evaluate
"";


// File: classFiber_1_1ModifiedHelmholtz3dHypersingularIntegrandFunctor.xml
%feature("docstring")
Fiber::ModifiedHelmholtz3dHypersingularIntegrandFunctor "";

%feature("docstring")
Fiber::ModifiedHelmholtz3dHypersingularIntegrandFunctor::ModifiedHelmholtz3dHypersingularIntegrandFunctor
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dHypersingularIntegrandFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dHypersingularIntegrandFunctor::waveNumber "";

%feature("docstring")
Fiber::ModifiedHelmholtz3dHypersingularIntegrandFunctor::evaluate "";


// File: classFiber_1_1ModifiedHelmholtz3dHypersingularTransformationFunctor.xml
%feature("docstring")
Fiber::ModifiedHelmholtz3dHypersingularTransformationFunctor "

Functor calculating basis-function transformations necessary for the
implementation of the hypersingular operator for the modified
Helmholtz equation in 3D.

Two following quantities are calculated: * shape-function value *
shape-function surface curl.

C++ includes:
modified_helmholtz_3d_hypersingular_transformation_functor.hpp ";


// File: classFiber_1_1ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor.xml
%feature("docstring")
Fiber::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor "

Single-layer-potential kernel functor for the modified Helmholtz
equation in 3D.

ValueType Type used to represent the values of the kernel. It can be
one of: float, double, std::complex<float> and std::complex<double>.
Note that setting ValueType to a real type implies that the wave
number will also be purely real.

See:   Modified Helmholtz equation in 3D

C++ includes:
modified_helmholtz_3d_single_layer_potential_kernel_functor.hpp ";

%feature("docstring")
Fiber::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor::kernelCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor::kernelRowCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor::kernelColCount
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor::waveNumber
"";

%feature("docstring")
Fiber::ModifiedHelmholtz3dSingleLayerPotentialKernelFunctor::evaluate
"";


// File: classFiber_1_1NonseparableNumericalTestKernelTrialIntegrator.xml
%feature("docstring")
Fiber::NonseparableNumericalTestKernelTrialIntegrator "

Integration over pairs of elements on non-tensor-product point grids.

C++ includes: nonseparable_numerical_test_kernel_trial_integrator.hpp
";

%feature("docstring")
Fiber::NonseparableNumericalTestKernelTrialIntegrator::NonseparableNumericalTestKernelTrialIntegrator
"";

%feature("docstring")
Fiber::NonseparableNumericalTestKernelTrialIntegrator::integrate "";

%feature("docstring")
Fiber::NonseparableNumericalTestKernelTrialIntegrator::integrate "";


// File: structFiber_1_1null__deleter.xml
%feature("docstring") Fiber::null_deleter "";


// File: classFiber_1_1NumericalQuadratureStrategy.xml
%feature("docstring") Fiber::NumericalQuadratureStrategy "";

%feature("docstring")
Fiber::NumericalQuadratureStrategy::NumericalQuadratureStrategy "

Construct a local assembler factory with default accuracy settings. ";

%feature("docstring")
Fiber::NumericalQuadratureStrategy::NumericalQuadratureStrategy "

Construct a local assembler factory with specified accuracy settings.
";


// File: classFiber_1_1NumericalQuadratureStrategy_3_01BasisFunctionType_00_01ResultType_00_01GeometryFac02b8733405c6d0215aac3970aca97313.xml
%feature("docstring") Fiber::NumericalQuadratureStrategy<
BasisFunctionType, ResultType, GeometryFactory, typename
boost::enable_if< boost::is_same< ResultType, typename ScalarTraits<
ResultType >::RealType > >::type > " ";

%feature("docstring")  Fiber::NumericalQuadratureStrategy<
BasisFunctionType, ResultType, GeometryFactory, typename
boost::enable_if< boost::is_same< ResultType, typename ScalarTraits<
ResultType >::RealType > >::type >::NumericalQuadratureStrategy "

Construct a local assembler factory with default accuracy settings. ";

%feature("docstring")  Fiber::NumericalQuadratureStrategy<
BasisFunctionType, ResultType, GeometryFactory, typename
boost::enable_if< boost::is_same< ResultType, typename ScalarTraits<
ResultType >::RealType > >::type >::NumericalQuadratureStrategy "

Construct a local assembler factory with specified accuracy settings.
";


// File: classFiber_1_1NumericalQuadratureStrategyBase.xml
%feature("docstring") Fiber::NumericalQuadratureStrategyBase "";

%feature("docstring")
Fiber::NumericalQuadratureStrategyBase::NumericalQuadratureStrategyBase
"

Construct a local assembler factory with default accuracy settings. ";

%feature("docstring")
Fiber::NumericalQuadratureStrategyBase::NumericalQuadratureStrategyBase
"

Construct a local assembler factory with specified accuracy settings.
";

%feature("docstring")
Fiber::NumericalQuadratureStrategyBase::makeAssemblerForIdentityOperators
"";

%feature("docstring")
Fiber::NumericalQuadratureStrategyBase::accuracyOptions "";


// File: classFiber_1_1NumericalTestFunctionIntegrator.xml
%feature("docstring") Fiber::NumericalTestFunctionIntegrator "

Integration over pairs of elements on tensor-product point grids.

C++ includes: numerical_test_function_integrator.hpp ";

%feature("docstring")
Fiber::NumericalTestFunctionIntegrator::NumericalTestFunctionIntegrator
"";

%feature("docstring")
Fiber::NumericalTestFunctionIntegrator::integrate "";


// File: classFiber_1_1NumericalTestTrialIntegrator.xml
%feature("docstring") Fiber::NumericalTestTrialIntegrator "

Integration over pairs of elements on tensor-product point grids.

C++ includes: numerical_test_trial_integrator.hpp ";

%feature("docstring")
Fiber::NumericalTestTrialIntegrator::NumericalTestTrialIntegrator "";

%feature("docstring")  Fiber::NumericalTestTrialIntegrator::integrate
"";


// File: classFiber_1_1OpenClHandler.xml
%feature("docstring") Fiber::OpenClHandler "";

%feature("docstring")  Fiber::OpenClHandler::OpenClHandler "";

%feature("docstring")  Fiber::OpenClHandler::UseOpenCl "";

%feature("docstring")  Fiber::OpenClHandler::pushGeometry "";


// File: structFiber_1_1OpenClOptions.xml
%feature("docstring") Fiber::OpenClOptions "";

%feature("docstring")  Fiber::OpenClOptions::OpenClOptions "";


// File: classFiber_1_1ParallelizationOptions.xml
%feature("docstring") Fiber::ParallelizationOptions "

Parallel operation settings.

C++ includes: parallelization_options.hpp ";

%feature("docstring")
Fiber::ParallelizationOptions::ParallelizationOptions "

Constructor. ";

%feature("docstring")  Fiber::ParallelizationOptions::enableOpenCl "

Enable GPU-based calculations (currently broken). ";

%feature("docstring")  Fiber::ParallelizationOptions::disableOpenCl "

Disable GPU-based calculations. ";

%feature("docstring")  Fiber::ParallelizationOptions::isOpenClEnabled
"

Return whether GPU-based calculations are enabled. ";

%feature("docstring")  Fiber::ParallelizationOptions::openClOptions "

Return current settings controlling operation of the GPU. ";

%feature("docstring")
Fiber::ParallelizationOptions::setMaxThreadCount "

Set the maximum number of threads used during the assembly.

maxThreadCount must be a positive number or AUTO. In the latter case
the number of threads is determined automatically by Intel Threading
Building Blocks. ";

%feature("docstring")  Fiber::ParallelizationOptions::maxThreadCount "

Return the maximum number of thread used during the assembly.

The returned value can be a positive number or AUTO. In the latter
case the number of threads is determined automatically by Intel
Threading Building Blocks. ";


// File: classFiber_1_1PiecewiseConstantScalarBasis.xml
%feature("docstring") Fiber::PiecewiseConstantScalarBasis "";

%feature("docstring")  Fiber::PiecewiseConstantScalarBasis::size "";

%feature("docstring")  Fiber::PiecewiseConstantScalarBasis::order "";

%feature("docstring")  Fiber::PiecewiseConstantScalarBasis::evaluate "";


// File: classFiber_1_1PiecewiseLinearContinuousScalarBasis.xml
%feature("docstring") Fiber::PiecewiseLinearContinuousScalarBasis "";

%feature("docstring")
Fiber::PiecewiseLinearContinuousScalarBasis::size "";

%feature("docstring")
Fiber::PiecewiseLinearContinuousScalarBasis::order "";

%feature("docstring")
Fiber::PiecewiseLinearContinuousScalarBasis::evaluate "";

%feature("docstring")
Fiber::PiecewiseLinearContinuousScalarBasis::clCodeString "";


// File: structFiber_1_1PiecewiseLinearContinuousScalarBasisTraits.xml
%feature("docstring")
Fiber::PiecewiseLinearContinuousScalarBasisTraits "";


// File: structFiber_1_1PiecewiseLinearContinuousScalarBasisTraits_3_012_00_01CoordinateType_00_01ValueType_01_4.xml
%feature("docstring")
Fiber::PiecewiseLinearContinuousScalarBasisTraits< 2, CoordinateType,
ValueType > " ";


// File: structFiber_1_1PiecewiseLinearContinuousScalarBasisTraits_3_013_00_01CoordinateType_00_01ValueType_01_4.xml
%feature("docstring")
Fiber::PiecewiseLinearContinuousScalarBasisTraits< 3, CoordinateType,
ValueType > " ";


// File: structFiber_1_1PiecewiseLinearContinuousScalarBasisTraits_3_014_00_01CoordinateType_00_01ValueType_01_4.xml
%feature("docstring")
Fiber::PiecewiseLinearContinuousScalarBasisTraits< 4, CoordinateType,
ValueType > " ";


// File: classFiber_1_1QuadratureOptions.xml
%feature("docstring") Fiber::QuadratureOptions "

Options controlling the order of numerical quadrature.

This class can be used to specify the order of numerical quadrature to
be used to approximate a certain class of integrals. The order can be
set either as absolute or as relative with respect to some default
value determined by the code doing the integration.

C++ includes: quadrature_options.hpp ";

%feature("docstring")  Fiber::QuadratureOptions::QuadratureOptions "

Construct a QuadratureOptions object corresponding to a default
integration order. ";

%feature("docstring")
Fiber::QuadratureOptions::setAbsoluteQuadratureOrder "

Set quadrature order to order. ";

%feature("docstring")
Fiber::QuadratureOptions::setRelativeQuadratureOrder "

Set quadrature order to a default value plus offset. ";

%feature("docstring")  Fiber::QuadratureOptions::quadratureOrder "

Get quadrature order assuming that its default value is defaultOrder.
";


// File: classFiber_1_1QuadratureStrategy.xml
%feature("docstring") Fiber::QuadratureStrategy "

Base class for quadrature strategies.

A quadrature strategy provides functions constructing local assemblers
used to discretize boundary operators and user-defined functions. A
particular quadrature strategy determines how the integrals involved
in this discretization are evaluated.

C++ includes: quadrature_strategy.hpp ";

%feature("docstring")
Fiber::QuadratureStrategy::makeAssemblerForIntegralOperators "

Allocate a Galerkin-mode local assembler for an integral operator with
complex kernel. ";

%feature("docstring")
Fiber::QuadratureStrategy::makeAssemblerForGridFunctions "

Allocate a local assembler for calculations of the projections of
complex-valued functions from a given space on a Fiber::Function. ";

%feature("docstring")
Fiber::QuadratureStrategy::makeEvaluatorForIntegralOperators "

Allocate an evaluator for an integral operator with complex-valued
kernel applied to a grid function. ";


// File: classFiber_1_1QuadratureStrategy_3_01BasisFunctionType_00_01ResultType_00_01GeometryFactory_00_070f9ede67158772bcef0675f969feca0.xml
%feature("docstring") Fiber::QuadratureStrategy< BasisFunctionType,
ResultType, GeometryFactory, typename boost::enable_if<
boost::is_same< ResultType, typename ScalarTraits< ResultType
>::RealType > >::type > "

Base class for quadrature strategies (variant with real ResultType).

A quadrature strategy provides functions constructing local assemblers
used to discretize boundary operators and user-defined functions. A
particular quadrature strategy determines how the integrals involved
in this discretization are evaluated.

This is the template specialization for real result types, therefore
it only accepts real-valued kernels and user functions.

C++ includes: quadrature_strategy.hpp ";


// File: classFiber_1_1QuadratureStrategyBase.xml
%feature("docstring") Fiber::QuadratureStrategyBase "";

%feature("docstring")
Fiber::QuadratureStrategyBase::~QuadratureStrategyBase "";

%feature("docstring")
Fiber::QuadratureStrategyBase::makeAssemblerForIntegralOperators "

Allocate a Galerkin-mode local assembler for an integral operator with
real kernel. ";

%feature("docstring")
Fiber::QuadratureStrategyBase::makeAssemblerForIdentityOperators "

Allocate a Galerkin-mode local assembler for the identity operator. ";

%feature("docstring")
Fiber::QuadratureStrategyBase::makeAssemblerForGridFunctions "

Allocate a local assembler for calculations of the projections of
functions from a given space on a Fiber::Function. ";

%feature("docstring")
Fiber::QuadratureStrategyBase::makeEvaluatorForIntegralOperators "

Allocate an evaluator for an integral operator with real kernel
applied to a grid function. ";


// File: classFiber_1_1RawGridGeometry.xml
%feature("docstring") Fiber::RawGridGeometry "";

%feature("docstring")  Fiber::RawGridGeometry::RawGridGeometry "";

%feature("docstring")  Fiber::RawGridGeometry::vertices "";

%feature("docstring")  Fiber::RawGridGeometry::elementCornerIndices "";

%feature("docstring")  Fiber::RawGridGeometry::auxData "";

%feature("docstring")  Fiber::RawGridGeometry::elementCount "";

%feature("docstring")  Fiber::RawGridGeometry::gridDimension "";

%feature("docstring")  Fiber::RawGridGeometry::worldDimension "";

%feature("docstring")  Fiber::RawGridGeometry::elementCornerIndices "

Indices of the corners of the given element. ";

%feature("docstring")  Fiber::RawGridGeometry::elementCornerCount "

Number of corners of the given element. ";

%feature("docstring")  Fiber::RawGridGeometry::vertices "";

%feature("docstring")  Fiber::RawGridGeometry::elementCornerIndices "";

%feature("docstring")  Fiber::RawGridGeometry::auxData "";

%feature("docstring")  Fiber::RawGridGeometry::setupGeometry "";


// File: classFiber_1_1ScalarFunctionValueElementaryFunctor.xml
%feature("docstring") Fiber::ScalarFunctionValueElementaryFunctor "";

%feature("docstring")
Fiber::ScalarFunctionValueElementaryFunctor::argumentDimension "";

%feature("docstring")
Fiber::ScalarFunctionValueElementaryFunctor::resultDimension "";

%feature("docstring")
Fiber::ScalarFunctionValueElementaryFunctor::addDependencies "";

%feature("docstring")
Fiber::ScalarFunctionValueElementaryFunctor::evaluate "";


// File: classFiber_1_1ScalarFunctionValueFunctor.xml
%feature("docstring") Fiber::ScalarFunctionValueFunctor "";


// File: structFiber_1_1ScalarTraits.xml
%feature("docstring") Fiber::ScalarTraits "";


// File: structFiber_1_1ScalarTraits_3_01double_01_4.xml
%feature("docstring") Fiber::ScalarTraits< double > " ";


// File: structFiber_1_1ScalarTraits_3_01float_01_4.xml
%feature("docstring") Fiber::ScalarTraits< float > " ";


// File: structFiber_1_1ScalarTraits_3_01std_1_1complex_3_01double_01_4_01_4.xml
%feature("docstring") Fiber::ScalarTraits< std::complex< double > > "
";


// File: structFiber_1_1ScalarTraits_3_01std_1_1complex_3_01float_01_4_01_4.xml
%feature("docstring") Fiber::ScalarTraits< std::complex< float > > "
";


// File: classFiber_1_1SeparableNumericalTestKernelTrialIntegrator.xml
%feature("docstring")
Fiber::SeparableNumericalTestKernelTrialIntegrator "

Integration over pairs of elements on tensor-product point grids.

C++ includes: separable_numerical_test_kernel_trial_integrator.hpp ";

%feature("docstring")
Fiber::SeparableNumericalTestKernelTrialIntegrator::SeparableNumericalTestKernelTrialIntegrator
"";

%feature("docstring")
Fiber::SeparableNumericalTestKernelTrialIntegrator::~SeparableNumericalTestKernelTrialIntegrator
"";

%feature("docstring")
Fiber::SeparableNumericalTestKernelTrialIntegrator::integrate "";

%feature("docstring")
Fiber::SeparableNumericalTestKernelTrialIntegrator::integrate "";


// File: classFiber_1_1SerialBlasRegion.xml
%feature("docstring") Fiber::SerialBlasRegion "

Management of the number of threads used by BLAS and LAPACK.

C++ includes: serial_blas_region.hpp ";

%feature("docstring")  Fiber::SerialBlasRegion::SerialBlasRegion "

Make BLAS and LAPACK use only 1 thread. ";

%feature("docstring")  Fiber::SerialBlasRegion::~SerialBlasRegion "

Restore the original number of threads used by BLAS and LAPACK. ";


// File: classFiber_1_1SimpleScalarKernelTrialIntegrandFunctor.xml
%feature("docstring") Fiber::SimpleScalarKernelTrialIntegrandFunctor "";

%feature("docstring")
Fiber::SimpleScalarKernelTrialIntegrandFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::SimpleScalarKernelTrialIntegrandFunctor::resultDimension "";

%feature("docstring")
Fiber::SimpleScalarKernelTrialIntegrandFunctor::evaluate "";


// File: classFiber_1_1SimpleTestScalarKernelTrialIntegrandFunctor.xml
%feature("docstring")
Fiber::SimpleTestScalarKernelTrialIntegrandFunctor "";

%feature("docstring")
Fiber::SimpleTestScalarKernelTrialIntegrandFunctor::addGeometricalDependencies
"";

%feature("docstring")
Fiber::SimpleTestScalarKernelTrialIntegrandFunctor::evaluate "";


// File: structFiber_1_1SingleQuadratureDescriptor.xml
%feature("docstring") Fiber::SingleQuadratureDescriptor "";


// File: classFiber_1_1SurfaceCurl3dElementaryFunctor.xml
%feature("docstring") Fiber::SurfaceCurl3dElementaryFunctor "";

%feature("docstring")
Fiber::SurfaceCurl3dElementaryFunctor::argumentDimension "";

%feature("docstring")
Fiber::SurfaceCurl3dElementaryFunctor::resultDimension "";

%feature("docstring")
Fiber::SurfaceCurl3dElementaryFunctor::addDependencies "";

%feature("docstring")  Fiber::SurfaceCurl3dElementaryFunctor::evaluate
"";


// File: classFiber_1_1SurfaceCurl3dFunctor.xml
%feature("docstring") Fiber::SurfaceCurl3dFunctor "";


// File: classFiber_1_1SurfaceNormalDependentFunction.xml
%feature("docstring") Fiber::SurfaceNormalDependentFunction "

Function to be used as a source term, depending on global coordinates
and on the surface normal.

The template parameter Functor should be a class with the following
interface:

class Functor { public: Type of the function's values (e.g. float or
std::complex<double>) typedef <implementiation-defined> ValueType;
typedef ScalarTraits<ValueType>::RealType CoordinateType;

Number of components of the function's arguments (\"point\" and
\"normal\") int argumentDimension() const;

Number of components of the function's result int resultDimension()
const;

Evaluate the function at the point \"point\", with vector normal to
the surface given in the argument \"normal\", and store result in the
array \"result\". All arrays will be preinitialised to correct
dimensions. void evaluate(const arma::Col<CoordinateType>& point,
const arma::Col<CoordinateType>& normal, arma::Col<ValueType>& result)
const; };

C++ includes: surface_normal_dependent_function.hpp ";

%feature("docstring")
Fiber::SurfaceNormalDependentFunction::SurfaceNormalDependentFunction
"";

%feature("docstring")
Fiber::SurfaceNormalDependentFunction::worldDimension "";

%feature("docstring")
Fiber::SurfaceNormalDependentFunction::codomainDimension "";

%feature("docstring")
Fiber::SurfaceNormalDependentFunction::addGeometricalDependencies "";

%feature("docstring")  Fiber::SurfaceNormalDependentFunction::evaluate
"";


// File: classFiber_1_1SurfaceNormalIndependentFunction.xml
%feature("docstring") Fiber::SurfaceNormalIndependentFunction "

Function defined via a user-supplied functor, depending only on global
coordinates.

The template parameter Functor should be a class with the following
interface:

class Functor { public: Type of the function's values (float, double,
std::complex<float> or std::complex<double>) typedef <implementiation-
defined> ValueType; typedef typename ScalarTraits<ValueType>::RealType
CoordinateType;

Number of components of the function's argument int
argumentDimension() const;

Number of components of the function's result int resultDimension()
const;

Evaluate the function at the point \"point\" and store result in the
array \"result\" The \"point\" and \"result\" arrays will be
preinitialised to correct dimensions. void evaluate(const
arma::Col<CoordinateType>& point, arma::Col<ValueType>& result) const;
};

C++ includes: surface_normal_independent_function.hpp ";

%feature("docstring")
Fiber::SurfaceNormalIndependentFunction::SurfaceNormalIndependentFunction
"";

%feature("docstring")
Fiber::SurfaceNormalIndependentFunction::worldDimension "";

%feature("docstring")
Fiber::SurfaceNormalIndependentFunction::codomainDimension "";

%feature("docstring")
Fiber::SurfaceNormalIndependentFunction::addGeometricalDependencies "";

%feature("docstring")
Fiber::SurfaceNormalIndependentFunction::evaluate "";


// File: classFiber_1_1TestFunctionIntegrator.xml
%feature("docstring") Fiber::TestFunctionIntegrator "

Integration of products of test functions and arbitrary functions over
elements.

C++ includes: test_function_integrator.hpp ";

%feature("docstring")
Fiber::TestFunctionIntegrator::~TestFunctionIntegrator "";

%feature("docstring")  Fiber::TestFunctionIntegrator::integrate "";


// File: classFiber_1_1TestKernelTrialIntegral.xml
%feature("docstring") Fiber::TestKernelTrialIntegral "

Evaluation of double integrals depending on test functions, kernels
and trial functions.

C++ includes: test_kernel_trial_integral.hpp ";

%feature("docstring")
Fiber::TestKernelTrialIntegral::~TestKernelTrialIntegral "";

%feature("docstring")
Fiber::TestKernelTrialIntegral::addGeometricalDependencies "";

%feature("docstring")
Fiber::TestKernelTrialIntegral::evaluateWithTensorQuadratureRule "";

%feature("docstring")
Fiber::TestKernelTrialIntegral::evaluateWithNontensorQuadratureRule "";


// File: classFiber_1_1TestKernelTrialIntegrator.xml
%feature("docstring") Fiber::TestKernelTrialIntegrator "

Integration over pairs of elements.

C++ includes: test_kernel_trial_integrator.hpp ";

%feature("docstring")
Fiber::TestKernelTrialIntegrator::~TestKernelTrialIntegrator "";

%feature("docstring")  Fiber::TestKernelTrialIntegrator::integrate "";

%feature("docstring")  Fiber::TestKernelTrialIntegrator::integrate "";


// File: classFiber_1_1TestTrialIntegrator.xml
%feature("docstring") Fiber::TestTrialIntegrator "

Integration of products of test and trial functions over elements.

C++ includes: test_trial_integrator.hpp ";

%feature("docstring")
Fiber::TestTrialIntegrator::~TestTrialIntegrator "";

%feature("docstring")  Fiber::TestTrialIntegrator::integrate "";


// File: namespacearma.xml


// File: namespaceBempp.xml
%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::tbb_hash_combine "";

%feature("docstring")  Bempp::pseudoinverse "";

%feature("docstring")
Bempp::FIBER_ITERATE_OVER_BASIS_AND_RESULT_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")  Bempp::reallyGetClusterIds "";

%feature("docstring")  Bempp::getClusterIds "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::allocateAhmedMblockArray "";

%feature("docstring")  Bempp::ahmedCast "";

%feature("docstring")  Bempp::ahmedCast "";

%feature("docstring")  Bempp::ahmedCast "";

%feature("docstring")  Bempp::ahmedCast "";

%feature("docstring")  Bempp::ahmedCast "";

%feature("docstring")  Bempp::isFirstClusterBigger "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::areEqual "";

%feature("docstring")  Bempp::acaOperatorSum "

Add two discrete boundary operators stored as H-matrices.

A std::bad_cast exception is thrown if the input operators can not be
cast to DiscreteAcaBoundaryOperator.

Parameters:
-----------

op1:  First operand.

op2:  Second operand.

eps:  ???

Todo look into M. Bebendorf's book.

Parameters:
-----------

maximumRank:  Maximum rank of blocks that should be considered low-
rank in the H-matrix to be constructed.

A shared pointer to a newly allocated discrete boundary operator
representing the sum of the operands op1 and op2 stored as a single
H-matrix. ";

%feature("docstring")  Bempp::scaledAcaOperator "

Multiply the H-matrix representation of a discrete boundary operator
by a scalar and wrap the result in a new discrete boundary operator.

A std::bad_cast exception is thrown if the input operator can not be
cast to DiscreteAcaBoundaryOperator

Parameters:
-----------

multiplier:  Scalar multiplier.

op:  Discrete boundary operator to be multiplied.

A shared pointer to a newly allocated discrete boundary operator
representing the operand op multiplied by multiplier and stored as a
H-matrix. ";

%feature("docstring")  Bempp::scaledAcaOperator "";

%feature("docstring")  Bempp::acaOperatorApproximateLuInverse "

LU Inverse of a discrete boundary operator stored as a H-matrix.

Parameters:
-----------

op:  Discrete boundary operator for which to compute the LU Inverse.

delta:  Approximation accuracy of the inverse.

A shared pointer to a newly allocated discrete boundary operator
representing the (approximate) LU inverse of op and stored as an
(approximate) LU decomposition of . ";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")  Bempp::INSTANTIATE_FREE_FUNCTIONS_WITH_SCALAR "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")  Bempp::solveWithAmesos "";

%feature("docstring")  Bempp::solveWithAmesos< double > " ";

%feature("docstring")  Bempp::solveWithAmesos< float > " ";

%feature("docstring")  Bempp::solveWithAmesos< std::complex< float > >
" ";

%feature("docstring")  Bempp::solveWithAmesos< std::complex< double >
> " ";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")  Bempp::reallyApplyBuiltInImpl "";

%feature("docstring")  Bempp::reallyApplyBuiltInImpl< double > " ";

%feature("docstring")  Bempp::reallyApplyBuiltInImpl< float > " ";

%feature("docstring")  Bempp::reallyApplyBuiltInImpl< std::complex<
float > > " ";

%feature("docstring")  Bempp::reallyApplyBuiltInImpl< std::complex<
double > > " ";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::gatherGlobalDofs "

Build a list of lists of global DOF indices corresponding to the local
DOFs on each element of space.grid(). ";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_KERNEL_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_KERNEL_AND_RESULT "";

%feature("docstring")  Bempp::reallyCalculateProjections "";

%feature("docstring")  Bempp::calculateProjections "

Calculate projections of the function on the basis functions of the
given dual space. ";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::helmholtz3dAdjointDoubleLayerBoundaryOperator "";

%feature("docstring")  Bempp::FIBER_ITERATE_OVER_BASIS_TYPES "";

%feature("docstring")  Bempp::FIBER_ITERATE_OVER_BASIS_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")  Bempp::waveNumberImpl "";

%feature("docstring")  Bempp::helmholtz3dDoubleLayerBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")  Bempp::FIBER_ITERATE_OVER_BASIS_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")  Bempp::helmholtz3dHypersingularBoundaryOperator
"";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")  Bempp::waveNumberImpl "";

%feature("docstring")  Bempp::helmholtz3dSingleLayerBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")  Bempp::FIBER_ITERATE_OVER_BASIS_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")  Bempp::epetraSumIntoGlobalValues "";

%feature("docstring")  Bempp::epetraSumIntoGlobalValues< double > " ";

%feature("docstring")  Bempp::epetraSumIntoGlobalValues< float > " ";

%feature("docstring")  Bempp::epetraSumIntoGlobalValues< std::complex<
float > > " ";

%feature("docstring")  Bempp::epetraSumIntoGlobalValues< std::complex<
double > > " ";

%feature("docstring")  Bempp::identityOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")
Bempp::laplace3dAdjointDoubleLayerBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_ITERATE_OVER_BASIS_AND_RESULT_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::laplace3dDoubleLayerBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_ITERATE_OVER_BASIS_AND_RESULT_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::laplace3dHypersingularBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::laplace3dSingleLayerBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_ITERATE_OVER_BASIS_AND_RESULT_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::modifiedHelmholtz3dAdjointDoubleLayerBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_ITERATE_OVER_BASIS_KERNEL_AND_RESULT_TYPES "";

%feature("docstring")
Bempp::FIBER_ITERATE_OVER_BASIS_KERNEL_AND_RESULT_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_KERNEL_AND_RESULT "";

%feature("docstring")  Bempp::waveNumberImpl "";

%feature("docstring")
Bempp::modifiedHelmholtz3dDoubleLayerBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_KERNEL_AND_RESULT "";

%feature("docstring")
Bempp::modifiedHelmholtz3dHypersingularBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_KERNEL_AND_RESULT "";

%feature("docstring")
Bempp::modifiedHelmholtz3dSingleLayerBoundaryOperator "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_KERNEL_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::autoSymmetry "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")  Bempp::surfaceNormalDependentFunction "

Construct a SurfaceNormalDependentFunction object from a given
functor.

This helper function takes an instance functor of a class Functor
providing an interface described in the documentation of
SurfaceNormalDependentFunction and uses it to construct a
SurfaceNormalDependentFunction object. The latter can subsequently be
passed into a constructor of the GridFunction class. ";

%feature("docstring")  Bempp::surfaceNormalIndependentFunction "

Construct a SurfaceNormalIndependentFunction object from a given
functor.

This helper function takes an instance functor of a class Functor
providing an interface described in the documentation of
SurfaceNormalIndependentFunction and uses it to construct a
SurfaceNormalIndependentFunction object. The latter can subsequently
be passed into a constructor of the GridFunction class. ";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::realPart "";

%feature("docstring")  Bempp::realPart "";

%feature("docstring")  Bempp::realPart "";

%feature("docstring")  Bempp::imagPart "";

%feature("docstring")  Bempp::imagPart "";

%feature("docstring")  Bempp::imagPart "";

%feature("docstring")  Bempp::toString "";

%feature("docstring")  Bempp::father "";

%feature("docstring")  Bempp::setupDuneGeometry "";

%feature("docstring")  Bempp::exportSingleDataSetToVtk "";

%feature("docstring")  Bempp::exportSingleDataSetToVtk "";

%feature("docstring")  Bempp::exportSingleDataSetToVtk "";

%feature("docstring")  Bempp::exportSingleDataSetToVtk "";

%feature("docstring")  Bempp::exportSingleDataSetToVtk "";

%feature("docstring")  Bempp::makeOperatorWithSolve "";

%feature("docstring")  Bempp::makeOperatorWithSolve "";

%feature("docstring")  Bempp::reallySolve "";

%feature("docstring")  Bempp::reallySolve "";

%feature("docstring")  Bempp::defaultGmresParameterListInternal "";

%feature("docstring")  Bempp::defaultCgParameterListInternal "";

%feature("docstring")  Bempp::defaultGmresParameterList "";

%feature("docstring")  Bempp::defaultGmresParameterList "";

%feature("docstring")  Bempp::defaultCgParameterList "";

%feature("docstring")  Bempp::defaultCgParameterList "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")  Bempp::acaDiscreteOperatorToPreconditioner "

Create a preconditioner from a DiscreteBoundaryOperator that
represents a H-Matrix.

Let $A$ be an H-Matrix. This method computes the H-Matrix LU
factorization $A\\\\approx LU$ and returns a DiscreteBoundaryOperator
object, which for a given vector $y$ performs the operation
$U^{-1}L^{-1}y$.

Parameters:
-----------

discreteOperator:  A DiscreteBoundaryOperator object, which represents
an ACA discretized boundary operator. Only operators that can be cast
to DiscreteAcaBoundaryOperator are allowed.

delta:  The accuracy of the approximate H-Matrix LU factorization. A
smaller value means better accuracy, but takes longer to compute
(default: delta=0.01). ";

%feature("docstring")  Bempp::acaBlockDiagonalPreconditioner "

Create a block diagonal preconditioner whose blocks are H-Matrix LU
decompositions.

Given operators $A_1,\\\\dots,A_N$, this method creates a block
diagonal preconditioning operator whose block diagonal entries are
solves with the H-Matrix LU decompositions of $A_1,\\\\dots,A_N$.

Parameters:
-----------

opVector:  A vector of pointers to DiscreteBoundaryOperator objects,
all of which must be castable to DiscreteAcaBoundaryOperator.

deltas:  A vector with tolerances for the H-Matrix LU decomposition of
each operator. ";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT "";

%feature("docstring")  Bempp::FIBER_ITERATE_OVER_VALUE_TYPES "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT_REAL_ONLY "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_RESULT_REAL_ONLY "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS_AND_RESULT "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")
Bempp::constructGlobalToFlatLocalDofsMappingVectors "";

%feature("docstring")
Bempp::constructGlobalToFlatLocalDofsMappingEpetraMatrix "";

%feature("docstring")  Bempp::getAllBases "

Get pointers to Basis objects corresponding to all elements of the
grid on which a function space is defined.

Parameters:
-----------

space:  A Space object.

bases:   Vector whose ith element is a pointer to the Basis object
representing the local degrees of freedom residing on the ith element
of the grid on which space is defined.

An exception is raised if space.assignDofs() has not been called prior
to calling this function. ";

%feature("docstring")
Bempp::constructOperatorMappingGlobalToFlatLocalDofs "";

%feature("docstring")
Bempp::constructOperatorMappingFlatLocalToGlobalDofs "";

%feature("docstring")
Bempp::FIBER_INSTANTIATE_CLASS_TEMPLATED_ON_BASIS "";

%feature("docstring")  Bempp::FIBER_ITERATE_OVER_BASIS_TYPES "";

%feature("docstring")
Bempp::FIBER_ITERATE_OVER_BASIS_AND_RESULT_TYPES "";


// File: namespaceBempp_1_1@0.xml


// File: namespaceBempp_1_1@100.xml


// File: namespaceBempp_1_1@11.xml


// File: namespaceBempp_1_1@110.xml


// File: namespaceBempp_1_1@16.xml


// File: namespaceBempp_1_1@272.xml


// File: namespaceBempp_1_1@28.xml


// File: namespaceBempp_1_1@299.xml


// File: namespaceBempp_1_1@42.xml


// File: namespaceBempp_1_1@44.xml


// File: namespaceBempp_1_1@48.xml


// File: namespaceBempp_1_1@57.xml


// File: namespaceBempp_1_1@62.xml


// File: namespaceBempp_1_1@70.xml


// File: namespaceBempp_1_1@75.xml


// File: namespaceboost.xml


// File: namespaceboost_1_1test__tools.xml


// File: namespaceboost_1_1test__tools_1_1tt__detail.xml


// File: namespaceDune.xml


// File: namespaceFiber.xml
%feature("docstring")  Fiber::conjugate "";

%feature("docstring")  Fiber::conjugate "";

%feature("docstring")  Fiber::conjugate "";

%feature("docstring")  Fiber::conjugate "";

%feature("docstring")  Fiber::evaluateBasisFunctionsWithDune "";

%feature("docstring")  Fiber::evaluateBasisFunctionDerivativesWithDune
"";

%feature("docstring")  Fiber::determineElementPairTopologyIn3D "";

%feature("docstring")  Fiber::reallyFillPointsAndWeightsRegular "";

%feature("docstring")  Fiber::remapPointsSharedVertex "";

%feature("docstring")  Fiber::remapPointsSharedEdge "";

%feature("docstring")  Fiber::remapPointsSharedVertexTriangle "";

%feature("docstring")  Fiber::remapPointsSharedVertexQuadrilateral "";

%feature("docstring")  Fiber::nonsharedVertexTriangle "";

%feature("docstring")  Fiber::remapPointsSharedEdgeTriangle "";

%feature("docstring")  Fiber::remapPointsSharedEdgeQuadrilateral "";

%feature("docstring")  Fiber::reallyFillPointsAndWeightsSingular "";

%feature("docstring")  Fiber::fillSingleQuadraturePointsAndWeights "

Retrieve points and weights for a quadrature over a single element.

Parameters:
-----------

elementCornerCount:  Number of corners of the element to be integrated
on.

accuracyOrder:  Accuracy order of the quadrature, i.e. its degree of
exactness.

points:  Quadrature points.

weights:  Quadrature weights. ";

%feature("docstring")
Fiber::fillDoubleSingularQuadraturePointsAndWeights "";

%feature("docstring")  Fiber::fillSingleQuadraturePointsAndWeights<
float > " ";

%feature("docstring")
Fiber::fillDoubleSingularQuadraturePointsAndWeights< float > " ";

%feature("docstring")  Fiber::fillSingleQuadraturePointsAndWeights<
double > " ";

%feature("docstring")
Fiber::fillDoubleSingularQuadraturePointsAndWeights< double > " ";

%feature("docstring")  Fiber::tbb_hasher "";

%feature("docstring")  Fiber::tbb_hasher "";

%feature("docstring")  Fiber::make_shared_from_ref "

Create a shared pointer from a reference to an object allocated on
stack.

The object will not be deleted when the shared pointer goes out of
scope. ";

%feature("docstring")  Fiber::make_shared_from_const_ref "";


// File: namespaceFiber_1_1@178.xml


// File: namespaceFiber_1_1@200.xml


// File: namespacestd.xml


// File: namespacetbb.xml
%feature("docstring")  tbb::tbb_hasher "";

%feature("docstring")  tbb::tbb_hasher "";

%feature("docstring")  tbb::tbb_hasher "";


// File: namespaceThyra.xml


// File: abstract__boundary__operator_8cpp.xml


// File: abstract__boundary__operator_8hpp.xml


// File: abstract__boundary__operator__composition_8cpp.xml


// File: abstract__boundary__operator__composition_8hpp.xml


// File: abstract__boundary__operator__id_8hpp.xml


// File: abstract__boundary__operator__pseudoinverse_8cpp.xml


// File: abstract__boundary__operator__pseudoinverse_8hpp.xml


// File: abstract__boundary__operator__sum_8cpp.xml


// File: abstract__boundary__operator__sum_8hpp.xml


// File: aca__approximate__lu__inverse_8cpp.xml


// File: aca__approximate__lu__inverse_8hpp.xml


// File: aca__global__assembler_8cpp.xml


// File: aca__global__assembler_8hpp.xml


// File: ahmed__aux_8hpp.xml
%feature("docstring")  Bempp::multaHvec_omp "";


// File: ahmed__aux__fwd_8hpp.xml


// File: ahmed__complex_8hpp.xml


// File: ahmed__leaf__cluster__array_8cpp.xml
%feature("docstring")  Bempp::pow2 "";


// File: ahmed__leaf__cluster__array_8hpp.xml


// File: assembly__options_8cpp.xml


// File: assembly__options_8hpp.xml


// File: blocked__boundary__operator_8cpp.xml


// File: blocked__boundary__operator_8hpp.xml


// File: blocked__operator__structure_8cpp.xml


// File: blocked__operator__structure_8hpp.xml


// File: boundary__operator_8cpp.xml


// File: boundary__operator_8hpp.xml


// File: context_8cpp.xml


// File: context_8hpp.xml


// File: discrete__aca__boundary__operator_8cpp.xml


// File: discrete__aca__boundary__operator_8hpp.xml


// File: discrete__blocked__boundary__operator_8cpp.xml


// File: discrete__blocked__boundary__operator_8hpp.xml


// File: discrete__boundary__operator_8cpp.xml


// File: discrete__boundary__operator_8hpp.xml


// File: discrete__boundary__operator__cache_8cpp.xml


// File: discrete__boundary__operator__cache_8hpp.xml


// File: discrete__boundary__operator__composition_8cpp.xml


// File: discrete__boundary__operator__composition_8hpp.xml


// File: discrete__boundary__operator__sum_8cpp.xml


// File: discrete__boundary__operator__sum_8hpp.xml


// File: discrete__dense__boundary__operator_8cpp.xml


// File: discrete__dense__boundary__operator_8hpp.xml


// File: discrete__inverse__sparse__boundary__operator_8cpp.xml


// File: discrete__inverse__sparse__boundary__operator_8hpp.xml


// File: discrete__sparse__boundary__operator_8cpp.xml


// File: discrete__sparse__boundary__operator_8hpp.xml


// File: elementary__abstract__boundary__operator_8cpp.xml


// File: elementary__abstract__boundary__operator_8hpp.xml


// File: elementary__integral__operator_8cpp.xml


// File: elementary__integral__operator_8hpp.xml


// File: elementary__potential__operator_8cpp.xml


// File: elementary__potential__operator_8hpp.xml


// File: elementary__regular__integral__operator_8hpp.xml


// File: elementary__singular__integral__operator_8hpp.xml


// File: evaluation__options_8cpp.xml


// File: evaluation__options_8hpp.xml


// File: assembly_2function_8hpp.xml


// File: fiber_2function_8hpp.xml


// File: grid__function_8cpp.xml


// File: grid__function_8hpp.xml


// File: helmholtz__3d__adjoint__double__layer__boundary__operator_8cpp.xml


// File: helmholtz__3d__adjoint__double__layer__boundary__operator_8hpp.xml


// File: helmholtz__3d__boundary__operator__base_8hpp.xml


// File: helmholtz__3d__boundary__operator__base__imp_8hpp.xml


// File: helmholtz__3d__double__layer__boundary__operator_8cpp.xml


// File: helmholtz__3d__double__layer__boundary__operator_8hpp.xml


// File: helmholtz__3d__double__layer__potential__operator_8cpp.xml


// File: helmholtz__3d__double__layer__potential__operator_8hpp.xml


// File: helmholtz__3d__hypersingular__boundary__operator_8cpp.xml


// File: helmholtz__3d__hypersingular__boundary__operator_8hpp.xml


// File: helmholtz__3d__potential__operator__base_8hpp.xml


// File: helmholtz__3d__potential__operator__base__imp_8hpp.xml


// File: helmholtz__3d__single__layer__boundary__operator_8cpp.xml


// File: helmholtz__3d__single__layer__boundary__operator_8hpp.xml


// File: helmholtz__3d__single__layer__potential__operator_8cpp.xml


// File: helmholtz__3d__single__layer__potential__operator_8hpp.xml


// File: identity__operator_8cpp.xml


// File: identity__operator_8hpp.xml


// File: index__permutation_8hpp.xml


// File: interpolated__function_8cpp.xml


// File: interpolated__function_8hpp.xml


// File: laplace__3d__adjoint__double__layer__boundary__operator_8cpp.xml


// File: laplace__3d__adjoint__double__layer__boundary__operator_8hpp.xml


// File: laplace__3d__boundary__operator__base_8hpp.xml


// File: laplace__3d__boundary__operator__base__imp_8hpp.xml


// File: laplace__3d__double__layer__boundary__operator_8cpp.xml


// File: laplace__3d__double__layer__boundary__operator_8hpp.xml


// File: laplace__3d__double__layer__potential__operator_8cpp.xml


// File: laplace__3d__double__layer__potential__operator_8hpp.xml


// File: laplace__3d__hypersingular__boundary__operator_8cpp.xml


// File: laplace__3d__hypersingular__boundary__operator_8hpp.xml


// File: laplace__3d__potential__operator__base_8hpp.xml


// File: laplace__3d__potential__operator__base__imp_8hpp.xml


// File: laplace__3d__single__layer__boundary__operator_8cpp.xml


// File: laplace__3d__single__layer__boundary__operator_8hpp.xml


// File: laplace__3d__single__layer__potential__operator_8cpp.xml


// File: laplace__3d__single__layer__potential__operator_8hpp.xml


// File: local__assembler__construction__helper_8hpp.xml


// File: modified__helmholtz__3d__adjoint__double__layer__boundary__operator_8cpp.xml


// File: modified__helmholtz__3d__adjoint__double__layer__boundary__operator_8hpp.xml


// File: modified__helmholtz__3d__boundary__operator__base_8hpp.xml


// File: modified__helmholtz__3d__boundary__operator__base__imp_8hpp.xml


// File: modified__helmholtz__3d__double__layer__boundary__operator_8cpp.xml


// File: modified__helmholtz__3d__double__layer__boundary__operator_8hpp.xml


// File: modified__helmholtz__3d__hypersingular__boundary__operator_8cpp.xml


// File: modified__helmholtz__3d__hypersingular__boundary__operator_8hpp.xml


// File: modified__helmholtz__3d__single__layer__boundary__operator_8cpp.xml


// File: modified__helmholtz__3d__single__layer__boundary__operator_8hpp.xml


// File: numerical__quadrature__strategy_8cpp.xml


// File: assembly_2numerical__quadrature__strategy_8hpp.xml


// File: fiber_2numerical__quadrature__strategy_8hpp.xml


// File: potential__operator_8hpp.xml


// File: scaled__abstract__boundary__operator_8cpp.xml


// File: scaled__abstract__boundary__operator_8hpp.xml


// File: scaled__discrete__boundary__operator_8cpp.xml


// File: scaled__discrete__boundary__operator_8hpp.xml


// File: scattered__range_8hpp.xml


// File: assembly_2surface__normal__dependent__function_8hpp.xml


// File: fiber_2surface__normal__dependent__function_8hpp.xml


// File: assembly_2surface__normal__independent__function_8hpp.xml


// File: fiber_2surface__normal__independent__function_8hpp.xml


// File: symmetry_8hpp.xml


// File: transposition__mode_8hpp.xml


// File: vector_8cpp.xml


// File: vector_8hpp.xml


// File: weak__form__aca__assembly__helper_8cpp.xml


// File: weak__form__aca__assembly__helper_8hpp.xml


// File: armadillo__fwd_8hpp.xml


// File: auto__timer_8hpp.xml


// File: boost__make__shared__fwd_8hpp.xml


// File: boost__ptr__map__fwd_8hpp.xml


// File: boost__ptr__vector__fwd_8hpp.xml


// File: boost__scoped__array__fwd_8hpp.xml


// File: boost__shared__array__fwd_8hpp.xml


// File: chunk__statistics_8hpp.xml


// File: common_8hpp.xml


// File: complex__aux_8hpp.xml


// File: deprecated_8hpp.xml


// File: lazy_8hpp.xml


// File: multidimensional__arrays_8hpp.xml


// File: not__implemented__error_8hpp.xml


// File: common_2scalar__traits_8hpp.xml


// File: fiber_2scalar__traits_8hpp.xml


// File: common_2shared__ptr_8hpp.xml


// File: fiber_2shared__ptr_8hpp.xml


// File: stl__io_8hpp.xml


// File: to__string_8hpp.xml


// File: common_2types_8hpp.xml


// File: fiber_2types_8hpp.xml


// File: doxygen__main_8hpp.xml


// File: __2d__array_8hpp.xml


// File: __2d__array__imp_8hpp.xml


// File: __3d__array_8hpp.xml


// File: __3d__array__imp_8hpp.xml


// File: __4d__array_8hpp.xml


// File: __4d__array__imp_8hpp.xml


// File: accuracy__options_8hpp.xml


// File: basis_8hpp.xml


// File: basis__data_8hpp.xml


// File: basis__transformation__functor__wrappers_8hpp.xml


// File: opencl_8h.xml


// File: cl__util_8cpp.xml


// File: cl__util_8hpp.xml
%feature("docstring")  file_contents "";

%feature("docstring")  oclErrorString "";


// File: collection__of__2d__arrays_8hpp.xml


// File: collection__of__2d__arrays__imp_8hpp.xml


// File: collection__of__3d__arrays_8hpp.xml


// File: collection__of__3d__arrays__imp_8hpp.xml


// File: collection__of__4d__arrays_8hpp.xml


// File: collection__of__4d__arrays__imp_8hpp.xml


// File: collection__of__basis__transformations_8hpp.xml


// File: collection__of__kernels_8hpp.xml


// File: conjugate_8hpp.xml


// File: default__collection__of__basis__transformations_8hpp.xml


// File: default__collection__of__basis__transformations__imp_8hpp.xml


// File: default__collection__of__kernels_8hpp.xml


// File: default__collection__of__kernels__imp_8hpp.xml


// File: default__evaluator__for__integral__operators_8hpp.xml


// File: default__evaluator__for__integral__operators__imp_8hpp.xml


// File: default__kernel__trial__integral_8hpp.xml


// File: default__kernel__trial__integral__imp_8hpp.xml


// File: default__local__assembler__for__grid__functions__on__surfaces_8hpp.xml


// File: default__local__assembler__for__grid__functions__on__surfaces__imp_8hpp.xml


// File: default__local__assembler__for__identity__operator__on__surface_8hpp.xml


// File: default__local__assembler__for__identity__operator__on__surface__imp_8hpp.xml


// File: default__local__assembler__for__integral__operators__on__surfaces_8hpp.xml


// File: default__local__assembler__for__integral__operators__on__surfaces__imp_8hpp.xml


// File: default__test__kernel__trial__integral_8hpp.xml


// File: default__test__kernel__trial__integral__imp_8hpp.xml


// File: dune__basis__helper_8hpp.xml


// File: element__pair__topology_8hpp.xml


// File: evaluator__for__integral__operators_8hpp.xml


// File: explicit__instantiation_8hpp.xml


// File: geometrical__data_8hpp.xml


// File: kernel__trial__integral_8hpp.xml


// File: laplace__3d__adjoint__double__layer__potential__kernel__functor_8hpp.xml


// File: laplace__3d__double__layer__potential__kernel__functor_8hpp.xml


// File: laplace__3d__single__layer__potential__kernel__functor_8hpp.xml


// File: local__assembler__for__grid__functions_8hpp.xml


// File: local__assembler__for__operators_8hpp.xml


// File: modified__helmholtz__3d__adjoint__double__layer__potential__kernel__functor_8hpp.xml


// File: modified__helmholtz__3d__double__layer__potential__kernel__functor_8hpp.xml


// File: modified__helmholtz__3d__hypersingular__integrand__functor_8hpp.xml


// File: modified__helmholtz__3d__hypersingular__transformation__functor_8hpp.xml


// File: modified__helmholtz__3d__single__layer__potential__kernel__functor_8hpp.xml


// File: nonseparable__numerical__test__kernel__trial__integrator_8hpp.xml


// File: nonseparable__numerical__test__kernel__trial__integrator__imp_8hpp.xml


// File: numerical__quadrature_8cpp.xml


// File: numerical__quadrature_8hpp.xml


// File: numerical__quadrature__strategy__imp_8hpp.xml


// File: numerical__test__function__integrator_8hpp.xml


// File: numerical__test__function__integrator__imp_8hpp.xml


// File: numerical__test__trial__integrator_8hpp.xml


// File: numerical__test__trial__integrator__imp_8hpp.xml


// File: opencl__handler_8cpp.xml


// File: opencl__handler_8hpp.xml


// File: opencl__options_8hpp.xml


// File: parallelization__options_8cpp.xml


// File: parallelization__options_8hpp.xml


// File: piecewise__constant__scalar__basis_8hpp.xml


// File: piecewise__linear__continuous__scalar__basis_8hpp.xml


// File: quadrature__options_8hpp.xml


// File: quadrature__strategy_8hpp.xml


// File: raw__grid__geometry_8hpp.xml


// File: scalar__function__value__functor_8hpp.xml


// File: separable__numerical__test__kernel__trial__integrator_8hpp.xml


// File: separable__numerical__test__kernel__trial__integrator__imp_8hpp.xml


// File: serial__blas__region_8cpp.xml


// File: serial__blas__region_8hpp.xml


// File: simple__scalar__kernel__trial__integrand__functor_8hpp.xml


// File: simple__test__scalar__kernel__trial__integrand__functor_8hpp.xml


// File: surface__curl__3d__functor_8hpp.xml


// File: test__function__integrator_8hpp.xml


// File: test__kernel__trial__integral_8hpp.xml


// File: test__kernel__trial__integrator_8hpp.xml


// File: test__trial__integrator_8hpp.xml


// File: armadillo__helpers_8hpp.xml
%feature("docstring")  boost::_armadillo_fieldvector_compare "";

%feature("docstring")  boost::_armadillo_fieldmatrix_compare "";


// File: concrete__element__mapper_8hpp.xml


// File: concrete__entity_8hpp.xml


// File: concrete__entity__decl_8hpp.xml


// File: concrete__entity__pointer_8hpp.xml


// File: concrete__geometry_8hpp.xml


// File: concrete__geometry__factory_8hpp.xml


// File: concrete__grid_8hpp.xml


// File: concrete__grid__view_8hpp.xml


// File: concrete__grid__view__imp_8hpp.xml


// File: concrete__id__set_8hpp.xml


// File: concrete__index__set_8hpp.xml


// File: concrete__range__entity__iterator_8hpp.xml


// File: concrete__subentity__iterator_8hpp.xml


// File: concrete__vtk__writer_8hpp.xml


// File: dune_8hpp.xml


// File: entity_8hpp.xml


// File: entity__iterator_8hpp.xml


// File: entity__pointer_8hpp.xml


// File: geometry_8hpp.xml


// File: geometry__factory_8hpp.xml


// File: geometry__imp_8hpp.xml


// File: geometry__type_8hpp.xml


// File: grid_8hpp.xml


// File: grid__factory_8cpp.xml


// File: grid__factory_8hpp.xml


// File: grid__parameters_8hpp.xml


// File: grid__view_8hpp.xml


// File: id__set_8hpp.xml


// File: index__set_8hpp.xml


// File: mapper_8hpp.xml


// File: reverse__element__mapper_8cpp.xml


// File: reverse__element__mapper_8hpp.xml


// File: structured__grid__factory_8hpp.xml


// File: vtk__writer_8hpp.xml


// File: vtk__writer__helper_8cpp.xml


// File: vtk__writer__helper_8hpp.xml


// File: belos__solver__wrapper_8cpp.xml


// File: belos__solver__wrapper_8hpp.xml


// File: belos__solver__wrapper__fwd_8hpp.xml


// File: blocked__solution_8cpp.xml


// File: blocked__solution_8hpp.xml


// File: default__direct__solver_8cpp.xml


// File: default__direct__solver_8hpp.xml


// File: default__iterative__solver_8cpp.xml


// File: default__iterative__solver_8hpp.xml


// File: preconditioner_8cpp.xml


// File: preconditioner_8hpp.xml


// File: real__wrapper__of__complex__thyra__linear__operator_8cpp.xml


// File: real__wrapper__of__complex__thyra__linear__operator_8hpp.xml


// File: real__wrapper__of__complex__thyra__preconditioner_8cpp.xml


// File: real__wrapper__of__complex__thyra__preconditioner_8hpp.xml


// File: solution_8cpp.xml


// File: solution_8hpp.xml


// File: solution__base_8cpp.xml


// File: solution__base_8hpp.xml


// File: solver_8cpp.xml


// File: solver_8hpp.xml


// File: piecewise__constant__scalar__space_8cpp.xml


// File: piecewise__constant__scalar__space_8hpp.xml


// File: piecewise__linear__continuous__scalar__space_8cpp.xml


// File: piecewise__linear__continuous__scalar__space_8hpp.xml


// File: scalar__space_8cpp.xml


// File: scalar__space_8hpp.xml


// File: space_8cpp.xml


// File: space_8hpp.xml


// File: group__assembly.xml


// File: group__abstract__boundary__operators.xml


// File: group__boundary__operators.xml


// File: group__discrete__boundary__operators.xml


// File: group__potential__operators.xml


// File: group__assembly__functions.xml


// File: group__weak__form__assembly.xml


// File: group__weak__form__assembly__internal.xml


// File: group__common.xml


// File: group__fiber.xml


// File: group__linalg.xml


// File: group__operators.xml


// File: group__identity.xml


// File: group__composite__boundary__operators.xml


// File: group__laplace__3d.xml


// File: group__helmholtz__3d.xml


// File: group__modified__helmholtz__3d.xml


// File: group__space.xml


// File: todo.xml


// File: deprecated.xml


// File: bug.xml


// File: dir_eb826f9642f0a99dab37a1d41f038054.xml


// File: dir_dabd1c0df553a60acff344fb0e12d304.xml


// File: dir_f153b2391ff85602f9b627ae332ed523.xml


// File: dir_9837dbf550ea95a4d1fc9c3d55be300e.xml


// File: dir_4b9877a26d409355f0e8eac349858e7b.xml


// File: dir_c20d3685cf0048c70bdd9efe1642b009.xml


// File: dir_5028cf33f541283d0090b49cf88d8d08.xml


// File: dir_2a45ce097c31f6a55bf19b0d98664d1d.xml

